<!DOCTYPE html><!--  This site was created in Webflow. http://www.webflow.com  -->
<!--  Last Published: Mon Mar 07 2022 15:51:18 GMT+0000 (Coordinated Universal Time)  -->
<html data-wf-page="615932414a67c03aca6dceec" data-wf-site="602f42d4d0eb6ddf9136273c">
<head>
  <meta charset="utf-8">
  <title>Data Structures</title>
  <meta content="Data Structures" property="og:title">
  <meta content="Data Structures" property="twitter:title">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="Webflow" name="generator">
  <link href="../css/normalize.css" rel="stylesheet" type="text/css">
  <link href="../css/webflow.css" rel="stylesheet" type="text/css">
  <link href="../css/juan-diegos-portfolio.webflow.css" rel="stylesheet" type="text/css">
  <!-- [if lt IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" type="text/javascript"></script><![endif] -->
  <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <link href="../images/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <link href="../images/webclip.png" rel="apple-touch-icon">
</head>
<body class="body">
  <div data-w-id="ff3ac0b1-c979-2917-beb2-e00e39f97f07" data-animation="over-right" data-collapse="medium" data-duration="400" data-easing="ease" data-easing2="ease" role="banner" class="navbar-3 w-nav">
    <div class="container-8 w-container">
      <a href="../index.html" class="nav-logo-link"><img src="../images/Logo-Name-Portfolio.png" alt="IMAGE" class="nav-logo"></a>
      <nav role="navigation" class="nav-menu-3 w-nav-menu">
        <a href="../index.html" class="nav-link home works w-nav-link">HOME</a>
        <a href="#" class="nav-link home works w-nav-link">SUMMARY</a>
        <a href="#" class="nav-link home works w-nav-link">FEATURES</a>
        <a href="#" class="nav-link home works code w-nav-link">CODE</a>
        <a href="#" class="nav-link home works w-nav-link">DESIGN</a>
      </nav>
      <div class="menu-button-2 w-nav-button">
        <div class="w-icon-nav-menu"></div>
      </div>
    </div>
  </div>
  <div class="section background-black curses wf-section">
    <div class="centered-container-7 this w-container">
      <h1 class="heading-curses this">Data Structures</h1>
      <p class="paragraph-5 curses">This project covers the organization of data and the algorithms!<br></p>
      <div class="div-block-24">
        <div class="rich-text-block-4 w-richtext">
          <p> <strong>Software Used</strong>   </p>
          <p><strong>Languages Used </strong>  </p>
        </div>
        <div class="rich-text-block-3 w-richtext">
          <p>Visual Studio</p>
          <p>C++</p>
        </div>
      </div>
    </div>
    <div class="div-block-32 dl curses">
      <div class="text-block-11">Feel Free to Download the Source Code.</div>
      <a href="https://github.com/JDMAXilius/Data-Structures.git" target="_blank" class="button-6 ds w-button">Source Code</a>
    </div>
    <div class="container-7 w-container">
      <h2 class="heading-26-curse-2"><strong>Project Topics</strong></h2>
      <p class="paragrahps-2 blog colum curses"><strong>Explanations<br>‍</strong>Dynamic Array<br>Vector<br>List<br>Dynamic List<br>Unordered Map<br>Dictionary<br>Binary Search Tree<br>Huffman Compression<br><strong>Code</strong><br>Dynamic Array<br>Vector<br>List<br>Dynamic List<br>Unordered Map<br>Dictionary<br>Binary Search Tree<br>Huffman Compression<strong><br></strong></p>
    </div>
    <section id="Features" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Objectives</strong></h2>
    </section>
    <div class="div-block-34 curses"><img src="../images/1-2rKGJ6h1regwmfMcty3SLw.png" loading="lazy" sizes="100vw" srcset="../images/1-2rKGJ6h1regwmfMcty3SLw-p-500.png 500w, ../images/1-2rKGJ6h1regwmfMcty3SLw-p-800.png 800w, ../images/1-2rKGJ6h1regwmfMcty3SLw-p-1080.png 1080w, ../images/1-2rKGJ6h1regwmfMcty3SLw-p-1600.png 1600w, ../images/1-2rKGJ6h1regwmfMcty3SLw.png 1804w" alt="image" class="image-19 curses"></div>
    <div class="container-7 w-container">
      <div class="rich-text-block-5 curses heading-curses w-richtext">
        <p>This project covers the organization of data and the algorithms that are used for sorting, searching, and problem solving. Students will learn how fundamental data structures and algorithms function and are implemented. Topics addressed in this course include managing complexity, linked structures, abstraction, analysis, vectors, lists, stacks, queues, trees, heaps, and graphs.</p>
      </div>
    </div>
    <section id="Code" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Programming Code</strong></h2>
    </section>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="6d698fcd-3d73-34e6-a87b-2a5a413ecd6f" class="dropdown-toggle-2 curses w-dropdown-toggle">
        <div data-w-id="6d698fcd-3d73-34e6-a87b-2a5a413ecd70" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Dynamic Array</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog">template&lt;typename Type&gt;<br>class DynArray { friend class TestSuite; // Giving access to test code Type* mArray;<br> unsigned int mSize;<br> unsigned int mCapacity;public: // Default constructor<br>// Creates a new object<br>// In: _startingCap An initial size to start the array at (optional)<br> DynArray(unsigned int _startingCap = 0) {<br> //mArray = new Type[_startingCap];<br> //mSize = 0;<br> if (_startingCap == 0)<br> {<br> mArray = nullptr;<br> }<br> else<br> {<br> mArray = new Type[_startingCap];<br> }<br> mCapacity = _startingCap;<br> } // Destructor<br> // Cleans up all dynamically allocated memory<br> ~DynArray() {<br> Clear();<br> } // Copy constructor<br> // Used to initialize one object to another<br> // In: _da The object to copy from<br> DynArray(const DynArray&amp; _da) {<br> *this = _da;<br> } // Assignment operator<br> // Used to assign one object to another<br> // In: _da The object to assign from<br> //<br> // Return: The invoking object (by reference)<br> // This allows us to daisy-chain<br> DynArray&amp; operator=(const DynArray&amp; _da) { if (this != &amp;_da)<br> {<br> delete[]mArray;<br> mCapacity = _da.mCapacity;<br> mSize = _da.mSize;<br> mArray = new Type[mCapacity];<br> for (size_t i = 0; i &lt; mSize; i++)<br> {<br> mArray[i] = _da.mArray[i]; <br> }<br> }<br> return *this;<br> } // Overloaded [] operator<br> // Used to access an element in the internal array (read-only)<br> // In: _index The index to access at<br> //<br> // Return: The item at the specified index (by reference)<br> const Type&amp; operator[](int _index) const {<br> <br> return mArray[_index];<br> <br> } // Overloaded [] operator<br> // Used to access an element in the internal array (writeable)<br> // In: _index The index to access at<br> //<br> // Return: The item at the specified index (by reference)<br> Type&amp; operator[](int _index) {<br> return mArray[_index];<br> } // Get the current number of elements actively being used<br> //<br> // Return: The current number of elements used<br> int Size() const {<br> return mSize;<br> } // Get the current capacity of the internal array<br> //<br> // Return: The capacity of the array<br> int Capacity() const {<br> <br> return mCapacity;<br> } // Clear the class for re-use<br> // Should clean up all dynamic memory and leave the object the same as if the default constructor had been called<br> void Clear() {<br> delete[]mArray;<br> mCapacity = 0;<br> mSize = 0;<br> mArray = nullptr;<br> } // Add an item to the end of the array<br> // Should resize the array if needed<br> // In: _data The item to be added<br> void Append(const Type&amp; _data) {<br> //mSize = _data;<br> mArray[mSize] = _data;<br> if (mSize &gt;= mCapacity)<br> {<br> /* mCapacity *= 2;<br> if (mCapacity == 0)<br> {<br> mCapacity = 1;<br> }*/<br> Reserve();<br> //mArray[mSize] = _data;<br> }<br> //mArray[mCapacity] = _data;<br> //mArray = new Type[_data];<br> //mArray[mSize] = _data;<br> mSize++;<br> } // Resizes the internal array, and copies all data over<br> // In: _newCapacity The new capacity of the array<br> // NOTE: If 0 is passed, the array should double in size<br> // If _newCapacity &lt; mCapacity, do nothing<br> //<br> // SPECIAL CASE: If mCapacity is 0, then it should be set to 1<br> void Reserve(unsigned int _newCapacity = 0) {<br> <br> Type* temp;<br> if (_newCapacity == 0)<br> {<br> mCapacity *= 2;<br> if (mCapacity==0)<br> {<br> mCapacity = 1;<br> }<br> _newCapacity = mCapacity;<br> }<br> if (_newCapacity &gt;= mCapacity)<br> {<br> /*mCapacity = _newCapacity;*/<br> temp = new Type[mCapacity];<br> for (size_t i = 0; i &lt; mSize; i++)<br> {<br> temp[i] = mArray[i];<br> }<br> mCapacity = _newCapacity;<br> /*for (size_t i = 0; i &lt; mCapacity; i++)<br> {<br> delete[] mArray[i];<br> }*/<br> delete[]mArray;<br> mArray = temp;<br> /*for (size_t i = 0; i &lt; mSize; i++)<br> {<br> mArray[i] = temp[i];<br> }*/<br> //delete temp;<br> }<br> <br> //delete[]temp;<br> }};<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="19026364-0117-bd0d-2f23-fd4daae4e079" class="dropdown-toggle-2 curses w-dropdown-toggle">
        <div data-w-id="19026364-0117-bd0d-2f23-fd4daae4e07a" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Vector</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog">inline bool IsPalindromeNumber(unsigned int _num) {<br> <br> int rev = 0;<br> bool check = false;<br> for (int i = _num; i &gt; 0; i /= 10)<br> {<br> rev = rev * 10 + i % 10;<br> }<br> if (_num == rev)<br> {<br> check = true;<br> }<br> <br> return check;<br>}<br>class DSA_Lab2<br>{<br> friend class TestSuite; // Giving access to test code<br>private: vector&lt;unsigned int&gt; mValues; // contains all of the values<br> vector&lt;unsigned int&gt; mPalindromes; // contains just the numbers that are palindromespublic: // Fill out the vector with the contents of the binary file<br> // First four bytes of the file are the number of ints in the file<br> //<br> // In: _input Name of the file to open<br> //<br> // Note: Make sure the vector is empty and shrunk to 0 capacity before adding values<br> void Fill(const char* _input) {<br> Clear();<br> ifstream ifl;<br> int ffbytes;<br> int ffbytes1;<br> ifl.open(_input, ios_base::binary);<br> ifl.read((char*)&amp;ffbytes, sizeof(int));<br> for (size_t i = 0; i &lt; ffbytes; i++)<br> {<br> ifl.read((char*)&amp;ffbytes1, sizeof(int));<br> mValues.push_back(ffbytes1);<br> } <br> mValues.shrink_to_fit();<br> ifl.close();<br> } // Fill out the vector with the contents of an array<br> //<br> // In: _arr The array of values<br> // _size The number of elements in the array<br> //<br> // Note: Make sure the vector is empty and shrunk to 0 capacity before adding values<br> void Fill(const unsigned int* _arr, int _size) {<br> Clear();<br> for (size_t i = 0; i &lt; _size; i++)<br> {<br> mValues.push_back(_arr[i]);<br> }<br> } // Remove all elements from vector and decrease capacity to 0<br> void Clear() {<br> //vector&lt;unsigned int&gt; erasemValues;<br> //delete mValues[];<br> mValues.clear();<br> //mValues.empty();<br> mValues.shrink_to_fit();<br> //erasemValues = mValues.erase(erasemValues);<br> //mValues[] = { 0 };<br> //mValues.reserve(0);<br> mPalindromes.clear();<br> mPalindromes.shrink_to_fit(); } // Sort the vector <br> //<br> // In: _ascending To sort in ascending order or not<br> void Sort(bool _ascending) {<br> if (_ascending==true)<br> {<br> sort(mValues.begin(), mValues.end());<br> }<br> else<br> {<br> sort(mValues.begin(), mValues.end(), greater&lt;&gt;());<br> }<br> } // Get an individual element from the mValues vector<br> int operator[](int _index) {<br> return mValues[_index];<br> } // Determine if a value is present in the vector<br> // <br> // In: _val The value to check for<br> //<br> // Return: True, if the value is present<br> bool Contains(unsigned int _val) const {<br> <br> bool check = false;<br> for (size_t i = 0; i &lt; mValues.size(); i++)<br> {<br> if (mValues[i] == _val)<br> {<br> check = true;<br> }<br> }<br> return check;<br> } // Move all palindrome numbers from mValues vector to mPalindromes vector<br> //<br> // Pseudocode:<br> // iterate through the main values vector<br> // if the value is a palindrome<br> // add it to the palindrome vector<br> // remove it from the values vector<br> void MovePalindromes() {<br> //vector&lt;unsigned int&gt; erasemValues= mValues.begin();<br> bool check; vector&lt;unsigned int&gt;::iterator iter = mValues.begin(); while (iter != mValues.end())<br> {<br> check = IsPalindromeNumber(*iter);<br> if (check == true)<br> {<br> mPalindromes.push_back(*iter);<br> iter=mValues.erase(iter);<br> }<br> ++iter;<br> }<br> }<br>};<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="5418fda6-e9f8-6873-9cc5-ffbfdd99ffc8" class="dropdown-toggle-2 curses w-dropdown-toggle">
        <div data-w-id="5418fda6-e9f8-6873-9cc5-ffbfdd99ffc9" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">List</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog">class DSA_Lab4 { friend class TestSuite; // Giving access to test code // Data members<br> list&lt;float&gt; mList;public: // Add all of the values from the array into the list using queue ordering<br> //<br> // In: _arr The array of values<br> // _size The number of elements in the array<br> //<br> // Note: Make sure the list is empty and shrunk to 0 capacity before adding values<br> void QueueOrderingAdd(const float* _arr, int _size) {<br> mList.clear();<br> for (size_t i = 0; i &lt; _size; i++)<br> {<br> mList.push_back(_arr[i]);<br> }<br> <br> } // Add all of the values from the array into the list using queue ordering<br> //<br> // In: _arr The array of values<br> // _size The number of elements in the array<br> //<br> // Note: Make sure the list is empty and shrunk to 0 capacity before adding values<br> void StackOrderingAdd(const float* _arr, int _size) {<br> mList.clear();<br> for (size_t i = 0; i &lt; _size; i++)<br> {<br> mList.push_front(_arr[i]);<br> } } // Remove a single value from the list using queue ordering<br> //<br> // Return: The value that was removed<br> float QueueOrderingRemove() {<br> mList.pop_back();<br> return mList.front();<br> } // Remove a single value from the list using stack ordering<br> //<br> // Return: The value that was removed<br> float StackOrderingRemove() {<br> mList.pop_back();<br> return mList.front();<br> } // Insert a value _index nodes away from the head node<br> // If _index is 0 - insert in front of the head/front node<br> // If _index is 5 - insert in front of the 5th node in the list<br> //<br> // Example: <br> // 0&lt;-[5]&lt;-&gt;[1]&lt;-&gt;[6]&lt;-&gt;[4]&lt;-&gt;[2]-&gt;0<br> // <br> // Inserting a 7 at index 2<br> //<br> // 0&lt;-[5]&lt;-&gt;[1]&lt;-&gt;[7]&lt;-&gt;[6]&lt;-&gt;[4]&lt;-&gt;[2]-&gt;0<br> //<br> //<br> // In: _val The value to insert<br> // _index The &quot;index&quot; to add at<br> void Insert(float _val, int _index) {<br> float temp=0;<br> for (list&lt;float&gt;:: iterator i = mList.begin(); i != mList.end(); ++i)<br> {<br> //mList.insert(i, _val);<br> if (temp == _index)<br> {<br> mList.insert(i, _val);<br> }<br> /*else if (_index == 5)<br> {<br> mList.push_front(temp);<br> }*/<br> temp++;<br> }<br> } // Insert a value at the spot specified by the iterator passed in<br> // <br> // In: _val The value to insert<br> // _iter The iterator at the place to insert<br> void Insert(float _val, list&lt;float&gt;::iterator _iter) {<br> mList.insert(_iter, _val);<br> /*for (list&lt;float&gt;::iterator i = mList.begin(); i != mList.end(); ++i)<br> {<br> mList.insert(_iter, _val);<br> }*/<br> } // Remove all values from mList that have a decimal place value larger than _decimal <br> // Example:   <br> // _decimal: 0.45<br> //<br> // mList: 498.28 // not removed, because .28 is not greater than .45<br> //   39812.181 // not removed, because .181 is not greater than .45<br> //   983.498 // removed, because .498 is greater than .45<br> //   3981.89 // removed, because .89 is greater than .45<br> //   487.2 // not removed, because .2 is not greater than .45<br> //<br> // With these values, the function would return 2<br> //<br> // In: _decimal The decimal value to check against (always less than 1.0)<br> //<br> // Return: The total number of values removed<br> int RemoveDecimalGreater(float _decimal) {<br> float dValues=0;<br> float total=0;<br> int tnvr=0;<br> for (list&lt;float&gt;::iterator i = mList.begin(); i != mList.end(); ++i)<br> { <br> dValues = (int)*i;<br> total = *i - dValues;<br> <br> if (total &gt; _decimal)<br> {<br> i = mList.erase(i);<br> //mList.remove(dValues);<br> tnvr++;<br> }<br> <br> /*i++;*/<br> }<br> return tnvr;<br> }<br>};<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="bd0fbf0e-5270-c79c-08c2-6a4bc928d273" class="dropdown-toggle-2 curses w-dropdown-toggle">
        <div data-w-id="bd0fbf0e-5270-c79c-08c2-6a4bc928d274" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Dynamic List</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog">template&lt;typename Type&gt;<br>class DList { friend class TestSuite; // Giving access to test code // Node structor a doubly linked list<br> struct Node { // Data members<br> Type data; // The value being stored<br> Node* next, * prev; // Pointers to the next and previous nodes // Constructor<br> //<br> // In: _data The value to store<br> // _next Pointer to the next node in the list<br> // _prev Pointer to the previous node in the list<br> Node(const Type&amp; _data, Node* _next = nullptr, Node* _prev = nullptr) {<br> //Node* n = new Node(?);<br> /*Node* n = new Node;<br> n-&gt;data=_data;<br> n-&gt;next = _next;<br> n-&gt;prev = _prev;*/<br> data = _data;<br> next = _next;<br> prev = _prev;<br> <br> }<br> };public: // An iterator class to made traversal more efficient<br> class Iterator {<br> public: // Data members<br> Node* mCurr; // Pre-fix increment operator<br> //<br> // Example:<br> // I - Iterator&#x27;s curr<br> // R - Return<br> /*<br> Before 0&lt;-[4]&lt;-&gt;[5]&lt;-&gt;[6]-&gt;0<br>  I After 0&lt;-[4]&lt;-&gt;[5]&lt;-&gt;[6]-&gt;0<br> I<br> R<br> */<br> // Return: The Iterator (the invoking object)<br> Iterator&amp; operator++() {<br> mCurr = mCurr-&gt;next;<br> return *this;<br> <br> /*int temp = val;<br> val += 1;<br> return temp;*/<br> } // Post-fix increment operator<br> //<br> // Example:<br> // I - Iterator&#x27;s curr<br> // R - Return<br> /*<br> Before 0&lt;-[4]&lt;-&gt;[5]&lt;-&gt;[6]-&gt;0<br>  I After 0&lt;-[4]&lt;-&gt;[5]&lt;-&gt;[6]-&gt;0<br>  R I */<br> // Return: The Iterator (before increment)<br> // NOTE: Will need a temporary pointer<br> Iterator operator++(int) {<br> Iterator temp=*this;<br> ++(*this);<br> return temp;<br> } // Pre-fix decrement operator<br> //<br> // Example:<br> // I - Iterator&#x27;s curr<br> // R - Return<br> /*<br> Before 0&lt;-[4]&lt;-&gt;[5]&lt;-&gt;[6]-&gt;0<br>  I After 0&lt;-[4]&lt;-&gt;[5]&lt;-&gt;[6]-&gt;0<br> I<br> R<br> */<br> // Return: The Iterator (the invoking object)<br> Iterator&amp; operator--() {<br> mCurr = mCurr-&gt;prev;<br> return *this; } // Post-fix decrement operator<br> //<br> // Example:<br> // I - Iterator&#x27;s curr<br> // R - Return<br> /*<br> Before 0&lt;-[4]&lt;-&gt;[5]&lt;-&gt;[6]-&gt;0<br>  I After 0&lt;-[4]&lt;-&gt;[5]&lt;-&gt;[6]-&gt;0<br> I  R */<br> // Return: The Iterator (before decrement)<br> // NOTE: Will need a temporary pointer<br> Iterator operator--(int) {<br> Iterator temp1 = *this;<br> --(*this);<br> return temp1;<br> } // Gets the value the iterator is currently pointing to<br> //<br> // Return: The data of the current iterator<br> Type&amp; operator*() {<br> Iterator temp2 = *this;<br> return temp2;<br> }<br> }; // Data members<br> Node* mHead; // The head (first node) of the list<br> Node* mTail; // The tail (last node) of the list<br> unsigned int mSize; // Current number of nodes being storedpublic: // Default constructor<br> // Creates a new empty linked list<br> DList() {<br> mHead = nullptr;<br> mTail = nullptr;<br> mSize=0;<br> } // Destructor<br> // Cleans up all dynamically allocated memory<br> ~DList() {<br> <br> Clear();<br> } // Copy constructor<br> // Used to initialize one object to another<br> //<br> // In: _copy The object to copy from<br> DList(const DList&amp; _copy) {<br> *this = _copy;<br> } // Assignment operator<br> // Used to assign one object to another<br> //<br> // In: _assign The object to assign from<br> //<br> // Return: The invoking object (by reference)<br> // This allows us to daisy-chain<br> DList&amp; operator=(const DList&amp; _assign) { if (this != &amp;_assign)<br> {<br> Clear();<br> delete mHead;<br> delete mTail;<br> mSize = _assign.mSize; Node* assingIter = _assign.mHead;<br> while (assingIter != nullptr)<br> {<br> Node* n = new Node(assingIter-&gt;data, nullptr, nullptr);<br> n-&gt;next = nullptr;<br> n-&gt;data = assingIter-&gt;data;<br> if (mTail !=nullptr)<br> {<br> mTail-&gt;next = n;<br> n-&gt;prev = mTail;<br> mTail = n;<br> }<br> else<br> {<br> n-&gt;prev = nullptr;<br> mHead=n;<br> mTail=n; }<br> assingIter = assingIter-&gt;next;<br> }<br> /*<br> for (size_t i = 0; i &lt; mSize; i++)<br> {<br> mHead[i] = _assign.mHead[i];<br> mTail[i] = _assign.mmTailt[i];<br> }*/<br> }<br> return *this;<br> }private: // Optional recursive helper method for use with Rule of 3<br> //<br> // In: _curr The current Node to copy<br> void Copy(const Node* _curr) { }public:<br> // Add a piece of data to the front of the list<br> //<br> // In: _data The object to add to the list<br> void AddHead(const Type&amp; _data) {<br> <br> Node* n = new Node(_data);<br> if (mHead == nullptr) {<br> mHead = n;<br> mTail = n;<br> }<br> else<br> {<br> <br> mHead-&gt;prev = n;<br> n-&gt;next = mHead;<br> mHead = n;<br> }<br> mSize++;<br> } // Add a piece of data to the end of the list<br> //<br> // In: _data The object to add to the list<br> void AddTail(const Type&amp; _data) {<br> <br> Node* n = new Node(_data);<br> if (mHead == nullptr) {<br> mTail = n;<br>            mHead = n;<br> }<br> else<br> { mTail-&gt;next = n;<br> n-&gt;prev = mTail;<br> mTail = n;<br> }<br> mSize++;<br> } // Clear the list of all dynamic memory<br> // Resets the list to its default state<br> void Clear() {<br> if (mHead != nullptr) {<br> <br> Node* tempH = mHead;<br> for (size_t i = 0; i &lt; mSize; i++)<br> {<br> Node* tempHN = tempH-&gt;next;<br> delete tempH;<br> tempH = tempHN;<br> }<br> mSize = 0;<br> mHead = nullptr;<br> mTail = nullptr;<br> }<br> }private: // Optional recursive helper method for use with Clear<br> // <br> // In: _curr The current Node to clear<br> void Clear(const Node* _curr) {<br> if (mHead != nullptr) {<br> _curr = mHead;<br> mHead = mHead-&gt;next;<br> delete _curr;<br> }<br> }public: // Insert a piece of data *before* the passed-in iterator<br> //<br> // In: _iter The iterator<br> // _data The value to add<br> //<br> // Example:<br> /*<br> Before 0&lt;-[4]&lt;-&gt;[5]&lt;-&gt;[6]-&gt;0<br>  I After 0&lt;-[4]&lt;-&gt;[9]&lt;-&gt;[5]&lt;-&gt;[6]-&gt;0<br>  I<br> */<br> // Return: The iterator<br> // SPECIAL CASE: Inserting at head or empty list<br> // NOTE: The iterator should now be pointing to the new node created<br> Iterator Insert(Iterator&amp; _iter, const Type&amp; _data) {<br> Node* n = new Node(_data); if (_iter.mCurr == nullptr || _iter.mCurr == mHead )<br> {<br> AddHead(_data);<br> _iter.mCurr = mHead; }<br> else<br> {<br> n-&gt;prev = _iter.mCurr-&gt;prev;<br> n-&gt;next = _iter.mCurr; _iter.mCurr-&gt;prev-&gt;next = n;<br> _iter.mCurr-&gt;prev = n;<br> _iter.mCurr = n;<br> }<br> //mSize++;<br> return _iter;<br> } // Erase a Node from the list<br> //<br> // In: _iter The iterator<br> //<br> // Example<br> /* Before 0&lt;-[4]&lt;-&gt;[5]&lt;-&gt;[6]-&gt;0<br>  I After 0&lt;-[4]&lt;-&gt;[6]-&gt;0<br>  I<br> */<br> // Return: The iterator<br> // SPECIAL CASE: Erasing head or tail<br> // NOTE: The iterator should now be pointing at the node after the one erased<br> Iterator Erase(Iterator&amp; _iter) {<br> Node* tempH;<br> if (_iter.mCurr == nullptr)<br> {<br> <br> /*for (size_t i = 0; i &lt; mSize; i++)<br> {<br> _iter = tempH-&gt;next;<br> delete tempH;<br> tempH = _iter;<br> }*/<br> }<br> else if(_iter.mCurr==mHead)<br> {<br> tempH = _iter.mCurr-&gt;next;<br> delete mHead;<br> mHead = tempH;<br> _iter.mCurr = mHead;<br> _iter.mCurr-&gt;prev = nullptr;<br> }<br> else if (_iter.mCurr == mTail)<br> {<br> tempH = _iter.mCurr-&gt;prev;<br> delete mTail;<br> mTail = tempH;<br> mTail-&gt;next = nullptr;<br> _iter.mCurr = mTail-&gt;next;<br> <br> }<br> else<br> {<br> tempH = _iter.mCurr;<br> _iter.mCurr-&gt;prev-&gt;next = _iter.mCurr-&gt;next;<br> _iter.mCurr-&gt;next-&gt;prev = _iter.mCurr-&gt;prev; Node* tempH1 = _iter.mCurr-&gt;next;<br> delete tempH;<br> <br> _iter.mCurr = tempH1;<br> <br> /*for (size_t i = 0; i &lt; mSize; i++)<br> {<br> _iter = tempH-&gt;prev;<br> delete tempH;<br> tempH = _iter;<br> }*/<br> }<br> mSize--;<br> return _iter;<br> } // Set an Iterator at the front of the list<br> // <br> // Return: An iterator that is pointing to the list&#x27;s head<br> Iterator Begin() {<br> Iterator n;<br> n.mCurr = mHead;<br> return n;<br> } // Set an Iterator pointing to the end of the list<br> // <br> // Return: An iterator that is pointing to a null pointer<br> Iterator End() {<br> Iterator n;<br> n.mCurr = mTail;<br> return n;<br> }<br>};<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="d76009d9-2702-4d11-c158-70908b291f6e" class="dropdown-toggle-2 curses w-dropdown-toggle">
        <div data-w-id="d76009d9-2702-4d11-c158-70908b291f6f" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Unordered Map</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog">class DSA_Lab6 { friend class TestSuite; // Giving access to test code // Data members<br> int mLetterValues[26];<br> unordered_map&lt;string, int&gt; mScrabbleMap;public: // In Scrabble, each letter has a value associated with it.<br> // This method will populate the array of letter values.<br> //<br> // In: _letterValues The array of 26 values<br> void PopulateLetterValues(const int* _letterValues) {<br> <br> for (size_t i = 0; i &lt; 26; i++)<br> {<br> mLetterValues[i] = _letterValues[i];<br> }<br> } // Retrieve the value of a particular letter<br> // <br> // In: _letter The letter to get the score for<br> //<br> // Return: The score value for the letter passed in<br> // NOTE: The letter passed in will always be upper-case<br> int GetLetterValue(char _letter) {<br> <br> /*char letter = &#x27; &#x27;;<br> for (size_t i = 0; i &lt; 26; i++)<br> {<br> letter = mLetterValues[i];<br> _letter = letter;<br> }*/<br> return mLetterValues[_letter - 65];<br> }<br> <br> // Get the value of a word<br> // This is done by adding up the values of each letter in the word<br> //<br> // In: _word The word to get the value of<br> //<br> // Return: The total value of the word<br> int GetWordValue(string _word) {<br> <br> int value = 0;<br> for (size_t i = 0; i &lt; _word.size(); i++)<br> {<br> value += GetLetterValue(_word[i]);<br> }<br> return value;<br> //return mLetterValues[_letter - 65];<br> } // Create a pair to add into the scrabbleMap<br> // This will have a &quot;first&quot; of the word, and a &quot;second&quot; of the total score<br> //<br> // In: _word The word for the pair<br> //<br> // Return: A pair that contains the word and the total score<br> pair&lt;string, int&gt; CreatePair(string _word) {<br> pair &lt;string, int&gt; vpair;<br> vpair.first = _word;<br> vpair.second = GetWordValue(_word);<br> return vpair;<br> } // Load a file containing all of the possible scrabble words, along with their values<br> // This file will contain one word per line<br> // In: _filename The name of the file to load<br> //<br> // Note: You may want to use one or more existing methods to help.<br> void LoadWords(const char* _filename) {<br> ifstream file(_filename);<br> string doc;<br> if (file.is_open())<br> {<br> while (getline(file,doc))<br> {<br> mScrabbleMap.insert(CreatePair(doc));<br> }<br> file.close();<br> }<br> //mScrabbleMap = unordered_map&lt;string, int&gt;;<br> }<br> <br> /**********************************/<br> /* ONLY FOR USE IN FindValueInMap */<br> /**********************************/<br> int values[26] = { 1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10 }; // Searches for a word in the map, and retrieves the score for that word<br> // This will make use of some of your previous methods<br> // Use above &quot;values&quot; array to populate your letter scores<br> // Use &quot;words.txt&quot; for loading words<br> //<br> // In: _word The word to search for<br> //<br> // Return: The word score for _word (or -1 if not found)<br> int FindValueInMap(string _word) {<br> PopulateLetterValues(values);<br> LoadWords(&quot;words.txt&quot;);<br> if (mScrabbleMap.find(_word) != mScrabbleMap.end())<br> {<br> return mScrabbleMap[_word];<br> }<br> else<br> {<br> return -1;<br> }<br> }<br>};<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="6f6a1ebc-6a82-ea84-a073-6cd2e4e9eb04" class="dropdown-toggle-2 curses w-dropdown-toggle">
        <div data-w-id="6f6a1ebc-6a82-ea84-a073-6cd2e4e9eb05" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Dictionary</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog">template&lt;typename Key, typename Value&gt;<br>class Dictionary { friend class TestSuite; // Giving access to test code // The objects stored in the hash-table<br> struct Pair {<br> Key key; // The key for insertion/lookup<br> Value value; // The data // Constructor<br> // In: _key<br> // _value<br> Pair(const Key&amp; _key, const Value&amp; _value) {<br> key = _key;<br> value = _value;<br> } // For testing<br> bool operator==(const Pair&amp; _comp) {<br> return (_comp.key == key &amp;&amp;<br> _comp.value == value);<br> }<br> }; list&lt;Pair&gt;* mTable; // A dynamic array of lists (these are the buckets)<br> unsigned int mNumBuckets; // Number of elements in mTable<br> unsigned int(*mHashFunc)(const Key&amp;); // Pointer to the hash functionpublic: // Constructor<br> // In: _numBuckets The number of elements to allocate<br> // _hashFunc The hashing function to be used<br> Dictionary(unsigned int _numBuckets, unsigned int (*_hashFunc)(const Key&amp;)) {<br> mNumBuckets = _numBuckets;<br> mHashFunc= _hashFunc;<br> mTable = new list&lt;Pair&gt;[mNumBuckets];<br> } // Destructor<br> // Cleans up any dynamically allocated memory<br> ~Dictionary() {<br> Clear();<br> delete[] mTable;<br> } // Copy constructor<br> // Used to initialize one object to another<br> // In: _dict The object to copy from<br> Dictionary(const Dictionary&amp; _dict) {<br> *this = _dict;<br> //this-&gt;copyDic(_dict);<br> } // Assignment operator<br> // Used to assign one object to another<br> // In: _dict The object to assign from<br> //<br> // Return: The invoking object (by reference)<br> // This allows us to daisy-chain<br> Dictionary&amp; operator=(const Dictionary&amp; _dict) {<br> <br> if (this != &amp;_dict)<br> {<br> Clear();<br> delete[] mTable;<br> mNumBuckets = _dict.mNumBuckets;<br> mHashFunc = _dict.mHashFunc;<br> mTable = new list&lt;Pair&gt;[mNumBuckets];<br> for (size_t i = 0; i &lt; mNumBuckets; i++)<br> {<br> mTable[i] = _dict.mTable[i];<br> }<br> }<br> return *this;<br> }<br> <br> // Clear<br> // Clears all internal data being stored<br> //  NOTE: Does not delete table or reset hash function<br> void Clear() {<br> <br> if (mTable != nullptr) { <br> for (size_t i = 0; i &lt; mNumBuckets; i++)<br> {<br> mTable[i].clear();<br> } }<br> } // Insert an item into the table<br> // In: _key The key to add at <br> // _value The value at the key<br> //<br> // NOTE: If there is already an item at the provided key, overwrite it.<br> void Insert(const Key&amp; _key, const Value&amp; _value) {<br> <br> <br> int hashValue = mHashFunc(_key);<br> //mTable[hashValue];<br> bool check = false; for (typename list&lt;Pair&gt;::iterator i = mTable[hashValue].begin(); i != mTable[hashValue].end(); i++)<br> {<br> <br> if (i-&gt;key == _key)<br> {<br> check = true;<br> i-&gt;value = _value;<br> }<br> }<br> if (!check)<br> {<br> Pair mtableValue = Pair(_key, _value);<br> mTable[hashValue].push_back(mtableValue);<br> }<br> <br> } // Find a value at a specified key<br> // In: _key The key to search for <br> //<br> // Return: A const pointer to the value at the searched key<br> // NOTE: Return a null pointer if key is not present<br> const Value* Find(const Key&amp; _key) {<br> <br> //const Value value;<br> int hashValue = mHashFunc(_key); for (typename list&lt;Pair&gt;::iterator i = mTable[hashValue].begin(); i != mTable[hashValue].end(); i++)<br> { //if (i-&gt;key != _key)<br> {<br> if (i-&gt;key == _key)<br> {<br> /*value = i-&gt;value;*/<br> return &amp;i-&gt;value;<br> <br> }<br> }<br> <br> }<br> return nullptr;<br> } // Remove a value at a specified key<br> // In: _key The key to remove<br> //<br> // Return: True, if an item was removed<br> bool Remove(const Key&amp; _key) {<br> bool check = false;<br> int hashValue = mHashFunc(_key);<br> <br> //list&lt;Pair&gt;::iterator i;<br> for (typename list&lt;Pair&gt;::iterator i= mTable[hashValue].begin(); i != mTable[hashValue].end(); i++)<br> { if (i-&gt;key == _key)<br> {<br> mTable[hashValue].erase(i);<br> check = true;<br> return true;<br> } else<br> {<br> check = false;<br> }<br> <br> } return false;<br> }<br>};<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="e5715a3c-446c-3fbe-5b67-3243f5cf28b9" class="dropdown-toggle-2 curses w-dropdown-toggle">
        <div data-w-id="e5715a3c-446c-3fbe-5b67-3243f5cf28ba" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Binary Search Tree</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog">template&lt;typename Type&gt;<br>class BST { friend class TestSuite; // Giving access to test code struct Node {<br> Type data;<br> Node* left, * right; // Constructor<br> // Creates a leaf node<br> //<br> // In: _data The value to store in this node<br> Node(const Type&amp; _data) {<br> this-&gt;data = _data;<br> this-&gt;left = nullptr;<br> this-&gt;right = nullptr;<br> }<br> }; // Data members<br> Node* mRoot;public: // Default constructor<br> // Creates an empty tree<br> BST() <br> { mRoot = nullptr;<br> /*mRoot-&gt;left = nullptr;<br> mRoot-&gt;right = nullptr;*/<br> <br> //data-&gt;left = nullptr;<br> /*left=nullptr;<br> right=nullptr;*/<br> /*this-&gt;left = nullptr;<br> this-&gt;right = nullptr;*/<br> //this-&gt;mRoot = NULL;<br> } // Destructor<br> // Clear all dynamic memory<br> ~BST() {<br> Clear();<br> } // Copy constructor<br> // Used to initialize one object to another<br> //<br> // In: _copy The object to copy from<br> BST(const BST&lt;Type&gt;&amp; _copy) {<br> *this = _copy;<br> }<br> // Assignment operator<br> // Used to assign one object to another<br> //<br> // In: _assign The object to assign from<br> //<br> // Return: The invoking object (by reference)<br> // This allows us to daisy-chain<br> BST&lt;Type&gt;&amp; operator=(const BST&lt;Type&gt;&amp; _assign) { Clear();<br> Copy(_assign.mRoot);<br> return *this;<br> }private: // Optional recursive helper method for use with Rule of 3<br> // <br> // In: _curr The current Node to copy<br> //<br> // NOTE: Use pre-order traversal<br> void Copy(const Node* _curr) {<br> if (_curr==nullptr)<br> {<br> return;<br> }<br> Push(_curr-&gt;data);<br> Copy(_curr-&gt;left);<br> Copy(_curr-&gt;right);<br> }public: // Clears out the tree and readies it for re-use<br> void Clear() {<br> <br> Clear(mRoot);<br> /*delete mRoot-&gt;left;<br> delete mRoot-&gt;right;*/<br> mRoot= nullptr;<br> }private: // Optional recursive helper method for use with Clear<br> // <br> // In: _curr The current Node to clear<br> //<br> // NOTE: Use post-order traversal<br> void Clear(Node* _curr) {<br> <br> if (_curr == nullptr)<br> {<br> return;<br> }<br> Clear(_curr-&gt;left);<br> Clear(_curr-&gt;right);<br> delete _curr;<br> /*delete left;<br> delete right;*/ }public: // Add a value into the tree<br> //<br> // In: _val The value to add<br> void Push(const Type&amp; _val) {<br> <br> //Node* nPush = new Node(_val);<br> //if (mRoot == nullptr)<br> //{<br> // <br> // //nPush-&gt;data = _val;<br> // mRoot = nPush;<br> //} //else<br> //{<br> // Push(_val, mRoot);<br> //} //<br> //Node* temp = nPush;<br> //delete nPush;<br> Push(_val, mRoot);<br> }private: // Optional recursive helper method for use with Push<br> //<br> // In: _val The value to add<br> // _curr The current Node being looked at<br> void Push(const Type&amp; _val, Node* _curr) {<br> if (mRoot == nullptr)<br> {<br> mRoot= new Node(_val);<br> }<br> else if (_curr-&gt;data &gt; _val)<br> {<br> if (_curr-&gt;left != nullptr)<br> {<br> Push(_val, _curr-&gt;left);<br> }<br> else<br> {<br> //Node* nPushL = new Node(_val);<br> _curr-&gt;left = new Node(_val);<br> }<br> }<br> else<br> {<br> if (_curr-&gt;right != nullptr)<br> {<br> Push(_val, _curr-&gt;right);<br> }<br> else<br> {<br> //Node* nPushR = new Node(_val);<br> _curr-&gt;right = new Node(_val);<br> }<br> }<br> }public: // Checks to see if a value is in the tree<br> //<br> // In: _val The value to search for<br> //<br> // Return: True, if found<br> bool Contains(const Type&amp; _val) { if (mRoot == nullptr)<br> {<br> return false;<br> }<br> else if (mRoot-&gt;data &lt; _val) <br> {<br> return true; <br> }<br> else if (mRoot-&gt;data == _val)<br> {<br> return true;<br> }<br> else<br> {<br> if (_val &lt; mRoot-&gt;data)<br> {<br> return false; <br> }<br> }<br> return false;<br> }<br> //// while (mRoot != nullptr)<br> //// {<br> //// if (mRoot-&gt;data &gt; _val)<br> //// {<br> //// //return mRoot-&gt;left.Contains(_val);<br> //// mRoot = mRoot-&gt;left;<br> //// //if (mRoot-&gt;data == _val)<br> //// //{<br> //// // return true;<br> //// // //break;<br> //// //}<br> //// }<br> //// else if (mRoot-&gt;data &lt; _val)<br> //// {<br> //// //return mRoot-&gt;right.Contains(_val);<br> //// mRoot = mRoot-&gt;right;<br> //// //if (mRoot-&gt;data == _val)<br> //// //{<br> //// // return true;<br> //// // //break;<br> //// //}<br> //// }<br> //// else if (mRoot-&gt;data == _val)<br> //// {<br> //// return true;<br> //// break;<br> //// }<br> //// }<br> //// if (mRoot == nullptr)<br> //// {<br> //// return false;<br> //// }<br> ////}<br> // <br> // //return true;<br> //// if (mRoot-&gt;data &lt; _val)<br> //// {<br> //// return true;<br> //// //this.data = data;<br> //// if (mRoot-&gt;left == nullptr)<br> //// {<br> //// return false;<br> //// }<br> //// else<br> //// {<br> //// return mRoot-&gt;left.Contains(_val);<br> //// }<br> //// }<br> //// else<br> //// {<br> //// return false;<br> //// //this.data = data;<br> //// if (mRoot-&gt;right == nullptr)<br> //// {<br> //// return false;<br> //// }<br> //// else<br> //// {<br> //// return mRoot-&gt;right.Contains(_val);<br> //// }<br> //// }<br> ////} // Removes a value from tree (first instance only)<br> //<br> // In: _val The value to search for<br> //<br> // Return: True, if a Node was removed<br> // NOTE: Keep in mind the three cases<br> // A) 2 children (&quot;fix&quot; tree)<br> // B) 0 children<br> // C) 1 child<br> bool Remove(const Type&amp; _val) {<br> Node* child = mRoot;<br> Node* parent = nullptr; while (child !=nullptr)<br> {<br> if (child-&gt;data &gt; _val)<br> {<br> parent = child;<br> child = child-&gt;left;<br> }<br> else if (child-&gt;data &lt; _val)<br> {<br> parent = child;<br> child = child-&gt;right;<br> }<br> else if (child-&gt;data == _val)<br> {<br> /*return true;*/<br> break;<br> }<br> } if (child == nullptr)<br> {<br> return false;<br> }<br> else<br> {<br> //case 02<br> if (child-&gt;left != nullptr &amp;&amp; child-&gt;right != nullptr)<br> {<br> Node* endtree = child-&gt;right;<br> while (endtree-&gt;left != nullptr)<br> {<br> parent = endtree;<br> endtree = endtree-&gt;left;<br> }<br> child-&gt;data = endtree-&gt;data;<br> child = endtree;<br> } //case 00<br> if (child-&gt;left == nullptr &amp;&amp; child-&gt;right == nullptr)<br> {<br> if (child==mRoot)<br> {<br> mRoot = nullptr;<br> }<br> else if (parent-&gt;left == child)<br> {<br> parent-&gt;left = nullptr;<br> }<br> else if (parent-&gt;right == child)<br> {<br> parent-&gt;right = nullptr;<br> }<br> delete child;<br> } //case 01<br> else if (child-&gt;left != nullptr || child-&gt;right != nullptr)<br> {<br> if (child == mRoot)<br> {<br> if (child-&gt;left !=nullptr)<br> {<br> mRoot = child-&gt;left;<br> }<br> else if (child-&gt;right != nullptr)<br> {<br> mRoot = child-&gt;right;<br> }<br> }<br> else if (parent-&gt;left == child)<br> {<br> if (child-&gt;right == nullptr)<br> {<br> parent-&gt;left = child-&gt;left;<br> }<br> else<br> {<br> parent-&gt;left = child-&gt;right;<br> }<br> }<br> else if (parent-&gt;right == child)<br> {<br> if (child-&gt;right == nullptr)<br> {<br> parent-&gt;right = child-&gt;left;<br> }<br> else<br> {<br> parent-&gt;right = child-&gt;right;<br> }<br> }<br> delete child;<br> }<br> <br> }<br> <br> return true;<br> } // Returns a space-delimited string of the tree in order<br> /*<br> Example:<br> 24<br> / \<br>   10  48<br> \   \<br> 12   50 Should return: &quot;10 12 24 48 50&quot;<br> */<br> // NOTE: Use to_string to convert an int to its string equivelent string InOrder() {<br> string sD;<br> InOrder(mRoot, sD);<br> sD.pop_back();<br> return sD;<br> }private: // Optional recursive helper method to help with InOrder<br> //<br> // In: _curr The current Node being looked at<br> // _str The string to add to<br> //<br> // NOTE: Use in-order traversal<br> void InOrder(Node* _curr, string&amp; _str) {<br> <br> if (_curr == nullptr)<br> {<br> return;<br> }<br> <br> if (_curr-&gt;left != nullptr)<br> {<br> InOrder(_curr-&gt;left, _str);<br> }<br> if (_curr-&gt;right != nullptr) // if left is not empty InOrder right<br> {<br> _str.append(to_string(_curr-&gt;data) + &quot; &quot;);<br> InOrder(_curr-&gt;right, _str);<br> }<br> if (_curr-&gt;right == nullptr) // if right is null add data to _str<br> {<br> _str.append(to_string(_curr-&gt;data) + &quot; &quot;);<br> }<br> }};<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="4e491f60-e9cf-c2cc-c1a7-66ca615d733f" class="dropdown-toggle-2 curses w-dropdown-toggle">
        <div data-w-id="4e491f60-e9cf-c2cc-c1a7-66ca615d7340" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Huffman Compression</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog">class Huffman { friend class TestSuite; // Giving access to test code // A node for a a Huffman tree<br> struct HuffNode {<br> short value; // The value to store (-1 if not a leaf node, 0-255 for the ascii value)<br> unsigned int freq; // The frequency of the node<br> HuffNode* left; // Left child<br> HuffNode* right; // Right child<br> HuffNode* parent; // Parent node // Constructor<br> // <br> // In: _value The value of the node<br> // _freq The frequency of the node<br> // _left The node&#x27;s left child (OPTIONAL)<br> // _right The node&#x27;s right child (OPTIONAL)<br> // _parent The parent node (OPTIONAL)<br> HuffNode(short _value, unsigned int _freq, HuffNode* _left = nullptr, HuffNode* _right = nullptr, HuffNode* _parent = nullptr)<br> : value(_value), freq(_freq), left(_left), right(_right), parent(_parent) {<br> /*value = _value;<br> freq = _freq;<br> left = _left;<br> right = _right;<br> parent = _parent;*/<br> } // Copy constructor<br> //<br> // In: _hnode The node to copy from<br> HuffNode(const HuffNode&amp; _hnode)<br> : value(_hnode.value), freq(_hnode.freq), left(_hnode.left), right(_hnode.right), parent(_hnode.parent) {<br> /**this = _hnode;*/<br> }<br> }; // A binary predicate used to compare HuffNodes<br> // This is used in the GenerateTree method<br> struct HuffCompare {<br> // Compare the frequency of two nodes<br> // <br> // In: _a The first node<br> // _b The second node<br> //<br> // Return: True, if _a&#x27;s freq is greater than _b&#x27;s freq<br> bool operator() (const HuffNode* _a, const HuffNode* _b) {<br> return(_a-&gt;freq &gt; _b-&gt;freq);<br> }<br> };<br> // Data members<br> string mFileName; // The name of the file to open for read/write<br> unsigned int mFrequencyTable[257]; // The frequency of each character in the file (the index in the array is the char&#x27;s ASCII value)<br> // [256] of the array is the total count of characters in the file<br> vector&lt;HuffNode*&gt; mLeafList; // Contains all of the dynamically allocated leaf nodes<br> HuffNode* mRoot; // The root of the huffman tree (set in GenerateTree)<br> vector&lt;bool&gt; mEncodingTable[256]; // Contains all of the bit-codes used to compress/decompress a file // Default constructor<br> //<br> // In: _fileName The name of the file to open<br> // _access The way to open the file<br> Huffman(string _fileName) {<br> // 1. Assign the data members the values from the parameters<br> mFileName = _fileName;<br> // 2. Zero out the frequency table<br> for (size_t i = 0; i &lt; 257; i++)<br> {<br> mFrequencyTable[i] = 0;<br> }<br> }<br> // Generate the frequency table for the Huffman algorithm (WRITING ONLY)<br> //<br> // NOTE: mFrequencyTable is an array of 257 unsigned ints representing the <br> // count of each character in the file (the index in the array is the char&#x27;s ASCII value)<br> // Example:  &#x27;A&#x27; is ASCII 65, so if A is the character being checked, [65] of your array would get incremented<br> // [256] of your array is the total count of characters in the file<br> void GenerateFrequencyTable() {<br> // 1. Open the file in binary mode<br> ifstream bFile(mFileName, ios::out | ios::binary); // 2. Get the total count of the file (This can also be done in the next step instead)<br> size_t totalCount; bFile.seekg(0, bFile.end);<br> totalCount = bFile.tellg();<br> bFile.seekg(0, bFile.beg);<br> // 3. Read the file one byte at a time, and increment the corresponding index<br> char* fByte = new char[totalCount];<br> bFile.read(fByte, totalCount); for (size_t i = 0; i &lt; totalCount; i++)<br> {<br> mFrequencyTable[fByte[i]]++;<br> mFrequencyTable[256]++;<br> //mFrequencyTable[(unsigned char)bFile.get()++];<br> } // 4. Close the file when complete<br> bFile.close();<br> delete[] fByte;<br> } // Generate the leaf list for the Huffman algorithm (used in READ AND WRITE)<br> //<br> // Note: Will cause leaks until ClearTree is implemented<br> void GenerateLeafList() {<br> // 1. Iterate through the frequency table (for all ASCII values) and dynamically create a leaf node for each non-0<br> // frequency.  Add it to the mLeafList vector.<br> for (short i = 0; i &lt; 256; i++)<br> {<br> if (mFrequencyTable[i] != 0)<br> {<br> struct HuffNode* leafList = new struct HuffNode(i, mFrequencyTable[i]);<br> mLeafList.push_back(leafList);<br> }<br> }<br> } // Generate a Huffman tree<br> void GenerateTree() {<br> // 1. Create the priority queue<br> // This will be storing HuffNode*&#x27;s<br> // in a vector, and will be using the HuffCompare for comparison<br> priority_queue&lt;HuffNode*, vector&lt;HuffNode*&gt;, HuffCompare&gt; pq;<br> // 2. Add in all values from your leaf list<br> for (size_t i = 0; i &lt; mLeafList.size(); i++)<br> {<br> pq.push(mLeafList[i]);<br> }<br> // 3. Enter the tree generation algorithm<br> // While the queue has more than 1 node<br> // Store the top two nodes into some temporary pointers and pop them<br> // Create a new parent node /w 1st node as left, and 2nd as right<br> // Set the parent value to -1, and frequency to the sum of its children<br> // Set the 1st and 2nd node&#x27;s parent to the new node you created<br> // Insert new node into queue while (pq.size() &gt; 1)<br> {<br> //Store the top two nodes into some temporary pointers and pop them<br> HuffNode* tempTopNode1 = pq.top();<br> pq.pop();<br> HuffNode* tempTopNode2 = pq.top();<br> pq.pop(); //Create a new parent node /w 1st node as left, and 2nd as right<br> HuffNode* parentNode=nullptr;<br> //Set the parent value to -1, and frequency to the sum of its children<br> /*parentNode-&gt;value = -1;<br> parentNode-&gt;freq = tempTopNode1-&gt;freq + tempTopNode2-&gt;freq;*/<br> parentNode = new HuffNode(-1, tempTopNode1-&gt;freq + tempTopNode2-&gt;freq, tempTopNode1, tempTopNode2); //Set the 1st and 2nd node&#x27;s parent to the new node you created<br> tempTopNode1-&gt;parent = parentNode;<br> tempTopNode2-&gt;parent = parentNode; //Insert new node into queue<br> pq.push(parentNode); } // 4. Set the root of the tree (this will be the only node in the queue)<br> mRoot = pq.top();<br> pq.pop();<br> } // Generating the encoding table for the Huffman algorithm<br> //<br> // Each vector will contain the bit-code corresponding to that index in the frequency table<br> void GenerateEncodingTable() {<br> // 1. Go through all of the leaf nodes and generate the bit codes<br> // You will do this by traversing up the tree from the leaf node<br> // As you move up, push a 0 to the vector if you passed through a left child connection<br> // and a 1 if you passed through a right<br> // Once you hit the root node, reverse the values in the vector<br> <br> HuffNode* bitCodes=nullptr; for (size_t i = 0; i &lt; mLeafList.size(); i++)<br> {<br>     bitCodes = mLeafList[i];<br> while (bitCodes-&gt;parent !=nullptr)<br> {<br> //As you move up, push a 0 to the vector if you passed through a left child connection<br> if (bitCodes-&gt;parent-&gt;left == bitCodes)<br> {<br> mEncodingTable[mLeafList[i]-&gt;value].push_back(0);<br> } //and a 1 if you passed through a right<br> if (bitCodes-&gt;parent-&gt;right == bitCodes)<br> {<br> mEncodingTable[mLeafList[i]-&gt;value].push_back(1);<br> } bitCodes = bitCodes-&gt;parent;<br> }<br> <br> //Once you hit the root node, reverse the values in the vector<br> reverse(mEncodingTable[mLeafList[i]-&gt;value].begin(), mEncodingTable[mLeafList[i]-&gt;value].end());<br> }<br> <br> } // Clear the tree of all dynamic memory (by using the helper function)<br> void ClearTree() {<br> // 1. Call the helper function with the root and then set it back to null<br> ClearTree(mRoot);<br> mRoot = nullptr;<br> } // Clear the tree of all dynamic memory (recursive helper function)<br> // <br> // In: _curr The current node to clean up<br> //<br> // Note: This will be a recursive function that does a post-order deletion<br> void ClearTree(HuffNode* _curr) {<br> if (_curr == nullptr)<br> {<br> return;<br> }<br> ClearTree(_curr-&gt;left);<br> ClearTree(_curr-&gt;right);<br> //free(_curr);<br> delete _curr;<br> } // Write a Huffman compressed file to disk<br> //<br> // In: _outputFile Where to write the compressed data to<br> //<br> // Note: You will use most of your other functionality to complete this function<br> void Compress(const char* _outputFile) {<br> // 1. Create the frequency table, leaf list, tree, and encoding table<br> GenerateFrequencyTable();<br> GenerateLeafList();<br> GenerateTree();<br> GenerateEncodingTable(); // 2. Create a BitOStream and supply it the huffman header<br> BitOStream bStremFile(_outputFile, (char*)mFrequencyTable, sizeof(int) * 257); <br> // 3. Open the input file in binary mode with a standard ifstream<br> ifstream bFile(mFileName, ios::out | ios::binary);<br> /*int totalCount;<br> bFile.seekg(0, bFile.end);<br> totalCount = bFile.tellg();<br> bFile.seekg(0, bFile.beg);<br> char* fByte = new char[totalCount]; bFile.read(fByte, totalCount);<br> char* fHead = new char[257*4];*/ // 4. Start the compression process.   (You can read the whole file into a buffer first if you want)<br> // For each character in the original file, write out the bit-code from the encoding table<br> /*for (size_t i = 0; i &lt; 257 * 4; i+=4)<br> {<br> memccpy((char*)&amp;fHead[i], (char*)&amp;mFrequencyTable[i / 4], 4);<br> }*/<br> <br> for (size_t i = 0; i &lt; mFrequencyTable[256]; i ++)<br> {<br> bStremFile &lt;&lt; mEncodingTable[(char)bFile.get()];<br> } // 5. Close the file streams when done<br> bFile.close();<br> bStremFile.Close();<br> // 6. Clear the tree (and optional buffer)<br> ClearTree();<br> } // Decompress a huffman-compressed file<br> //<br> // In: _outputFile Where to write the uncompressed data to<br> //<br> // Note: The mFileName will be the compressed file<br> void Decompress(const char* _outputFile) {<br> // 1. Create a BitIStream and read the frequency table<br> BitIStream bStreamFile(mFileName.c_str(), (char*)mFrequencyTable, sizeof(int) * 257);<br> // 2. Create the leaf list and tree<br> GenerateLeafList();<br> GenerateTree(); // 3. Create the stream for output (binary mode)<br> ofstream oStreamFile(_outputFile, ios_base::binary);<br> // 4. Create a bool to use for traversing down the list, and a char to store the character for writing<br> bool check;<br> char store;<br> // 5. Create a node pointer for use in traversing the list (start it at the top)<br> HuffNode* nodetrav = mRoot;<br> // 6. Go through the compressed file one bit at a time, traversing through the tree<br> // When you get to a leaf node, write out the value, and go back to the root<br> // Note: Remember, there may be trailing 0&#x27;s at the end of the file, so only loop the appropriate number of times<br> for (size_t i = 0; i &lt; mFrequencyTable[256]; i++)<br> {<br> //while (!bStreamFile.eof())<br> while (nodetrav-&gt;right != nullptr &amp;&amp; nodetrav-&gt;left != nullptr)<br> {<br> bStreamFile &gt;&gt; check;<br> /*if (nodetrav != nullptr &amp;&amp; nodetrav-&gt;left != nullptr)*/<br> <br> if (check == true)<br> {<br> nodetrav = nodetrav-&gt;right;<br> }<br> else<br> {<br> nodetrav = nodetrav-&gt;left;<br> }<br> }<br> store=(char)nodetrav-&gt;value;<br> oStreamFile &lt;&lt; store;<br> nodetrav = mRoot;<br> }<br> // 7. Close the streams<br> bStreamFile.Close();<br> oStreamFile.close();<br> // 8. Clean up the dynamic memory by clearing the tree<br> ClearTree();<br> }<br>};<br></p>
        </div>
      </nav>
    </div>
    <section id="Features" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Guidance</strong></h2>
    </section>
    <div class="container-7 w-container">
      <div class="rich-text-block-5 blog heading-curses w-richtext">
        <p>Set Up the basic structure of each data type!</p>
      </div>
    </div>
    <section id="Features" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Programming Explanation</strong></h2>
    </section>
    <div class="container-7 w-container">
      <div class="rich-text-block-5 curses heading-curses w-richtext">
        <p><strong>What is a Dynamic Array?</strong></p>
        <p>A dynamic array is quite similar to a regular array, but its size is modifiable during program runtime. DynamArray elements occupy a contiguous block of memory.</p>
        <p>Once an array has been created, its size cannot be changed. However, a dynamic array is different. A dynamic array can expand its size even after it has been filled.</p>
        <p>During the creation of an array, it is allocated a predetermined amount of memory. This is not the case with a dynamic array as it grows its memory size by a certain factor when there is a need.</p>
        <p>‍</p>
        <p><strong>Vector </strong></p>
        <p>Vectors are same as dynamic arrays with the ability to resize itself automatically when an element is inserted or deleted, with their storage being handled automatically by the container. Vector elements are placed in contiguous storage so that they can be accessed and traversed using iterators. In vectors, data is inserted at the end. Inserting at the end takes differential time, as sometimes there may be a need of extending the array. Removing the last element takes only constant time because no resizing happens. Inserting and erasing at the beginning or in the middle is linear in time.</p>
        <p> </p>
        <p><strong>List</strong></p>
        <p>Lists are sequence containers that allow constant time insert and erase operations anywhere within the sequence, and iteration in both directions.<br><br>List containers are implemented as doubly-linked lists; Doubly linked lists can store each of the elements they contain in different and unrelated storage locations. The ordering is kept internally by the association to each element of a link to the element preceding it and a link to the element following it.</p>
        <p>‍</p>
        <p><strong>Dynamic List</strong></p>
        <p>Linked lists are inherently <em>dynamic</em> data structures; they rely on new anddelete (or malloc and free) for their operation. Normally, dynamic memory management is provided by the C/C++ standard library, with help fromthe operating system. However, nothing stops us from writing our own <em>allocator</em>,providing the same services as malloc and free.</p>
        <p> </p>
        <p><strong>Unordered Map</strong></p>
        <p>The unordered_map in C++ is like a <strong>data structure of dictionary type that store element</strong>. It has a sequence of (key, value) pair, which allows fast retrieval of an individual element based on their unique key.</p>
        <p>‍</p>
        <p><strong>Dictionary</strong></p>
        <p>A dictionary is defined as a general-purpose data structure for storing a group of objects. A dictionary is associated with a set of keys and each key has a single associated value. Whenpresented with a key, the dictionary will simply return the associated value.</p>
        <p>‍</p>
        <p><strong>Binary Search Tree</strong></p>
        <p>A Binary Search Tree or BST as it is popularly called is a binary tree that fulfills the following conditions:</p>
        <ol role="list">
          <li>The nodes that are lesser than the root node which is placed as left children of the BST.</li>
          <li>The nodes that are greater than the root node that is placed as the right children of the BST.</li>
          <li>The left and right subtrees are in turn the binary search trees.</li>
        </ol>
        <p>This arrangement of ordering the keys in a particular sequence facilitates the programmer to carry out operations like searching, inserting, deleting, etc. more efficiently. If the nodes are not ordered, then we might have to compare each and every node before we can get the operation result.</p>
        <p>‍</p>
        <p><strong>Huffman Compression</strong></p>
        <p>Huffman coding is a lossless data compression algorithm. The idea is to assign variable-length codes to input characters, lengths of the assigned codes are based on the frequencies of corresponding characters. The most frequent character gets the smallest code and the least frequent character gets the largest code.</p>
      </div>
    </div>
  </div>
  <div class="section-2 footer background-black wf-section">
    <div class="container-4 w-container">
      <div class="footer-holder">
        <div class="social-wrapper">
          <a href="https://juan_diego_lugo.artstation.com" target="_blank" class="social-link w-inline-block"><img src="../images/Artstation.png" loading="lazy" alt="" class="image-13"></a>
          <a href="https://github.com/JDMAXilius" target="_blank" class="social-link w-inline-block"><img src="../images/github.png" loading="lazy" alt="image" class="image-13"></a>
          <a href="https://www.youtube.com/channel/UCRjr5hvDeIpc_SfgTO690RA/featured" target="_blank" class="social-link w-inline-block"><img src="../images/youtube.png" loading="lazy" alt="" class="image-13"></a>
          <a href="#" class="social-link w-inline-block"><img src="../images/pngfind.com-discord-icon-png-283551.png" loading="lazy" sizes="(max-width: 479px) 50vw, 40px" srcset="../images/pngfind.com-discord-icon-png-283551-p-500.png 500w, ../images/pngfind.com-discord-icon-png-283551-p-800.png 800w, ../images/pngfind.com-discord-icon-png-283551-p-1080.png 1080w, ../images/pngfind.com-discord-icon-png-283551.png 1468w" alt="" class="image-13"></a>
          <a href="https://www.facebook.com/juandiego.lugo1" target="_blank" class="social-link w-inline-block"><img src="../images/fb.png" loading="lazy" alt="" class="image-13 f"></a>
          <a href="#" class="social-link w-inline-block"><img src="../images/Instagram.svg" loading="lazy" alt="Instagram logo" class="image-13"></a>
          <a href="https://www.linkedin.com/in/juan-diego-lugo-929a34205/" class="social-link w-inline-block"><img src="../images/LinkedIn.svg" loading="lazy" alt="LinkedIn logo" class="image-14"></a>
        </div><img src="https://uploads-ssl.webflow.com/602ca53e736379cc95d5f180/602ca53e58ea7fb6bb114f5c_Logo.svg" loading="lazy" width="187" alt="" class="image">
        <div class="text-block-3">@Juan Diego 2021<br>‍</div>
      </div>
    </div>
  </div>
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=602f42d4d0eb6ddf9136273c" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="../js/webflow.js" type="text/javascript"></script>
  <!-- [if lte IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/placeholders/3.0.2/placeholders.min.js"></script><![endif] -->
</body>
</html>