<!DOCTYPE html><!--  This site was created in Webflow. http://www.webflow.com  -->
<!--  Last Published: Mon Mar 07 2022 15:12:52 GMT+0000 (Coordinated Universal Time)  -->
<html data-wf-page="61591c295b3a22b24e4b5e14" data-wf-site="602f42d4d0eb6ddf9136273c">
<head>
  <meta charset="utf-8">
  <title>Raster Surface Stone</title>
  <meta content="Raster Surface Stone" property="og:title">
  <meta content="Raster Surface Stone" property="twitter:title">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="Webflow" name="generator">
  <link href="../css/normalize.css" rel="stylesheet" type="text/css">
  <link href="../css/webflow.css" rel="stylesheet" type="text/css">
  <link href="../css/juan-diegos-portfolio.webflow.css" rel="stylesheet" type="text/css">
  <!-- [if lt IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" type="text/javascript"></script><![endif] -->
  <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <link href="../images/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <link href="../images/webclip.png" rel="apple-touch-icon">
</head>
<body class="body">
  <div data-w-id="ff3ac0b1-c979-2917-beb2-e00e39f97f07" data-animation="over-right" data-collapse="medium" data-duration="400" data-easing="ease" data-easing2="ease" role="banner" class="navbar-3 w-nav">
    <div class="container-8 w-container">
      <a href="../index.html" class="nav-logo-link"><img src="../images/Logo-Name-Portfolio.png" alt="IMAGE" class="nav-logo"></a>
      <nav role="navigation" class="nav-menu-3 w-nav-menu">
        <a href="../index.html" class="nav-link home works w-nav-link">HOME</a>
        <a href="#" class="nav-link home works w-nav-link">SUMMARY</a>
        <a href="#" class="nav-link home works w-nav-link">FEATURES</a>
        <a href="#" class="nav-link home works code w-nav-link">CODE</a>
        <a href="#" class="nav-link home works w-nav-link">DESIGN</a>
      </nav>
      <div class="menu-button-2 w-nav-button">
        <div class="w-icon-nav-menu"></div>
      </div>
    </div>
  </div>
  <div class="section background-black curses wf-section">
    <div class="centered-container-7 this curses w-container">
      <h1 class="heading-curses this curses">Raster Surface Stone</h1>
      <p class="paragraph-5 curses">This project is about the introduction of lighting concepts and model loading<br></p>
      <div class="div-block-24">
        <div class="rich-text-block-4 w-richtext">
          <p> <strong>Software Used</strong>   </p>
          <p><strong>Languages Used </strong>  </p>
        </div>
        <div class="rich-text-block-3 w-richtext">
          <p>Visual Studio</p>
          <p>C++</p>
        </div>
      </div>
    </div>
    <div class="div-block-32 dl curses">
      <div class="text-block-11">Feel Free to Download the Source Code.</div>
      <a href="https://github.com/JDMAXilius/Raster-Surface-Texture-Array.git" target="_blank" class="button-6 ds w-button">Source Code</a>
    </div>
    <div class="container-7 curses w-container">
      <h2 class="heading-26-curse-2"><strong>Project Topics</strong></h2>
      <div class="div-block-35 curses">
        <p id="w-node-_3d85396c-e759-1a32-368c-1ce1209db81b-4e4b5e14" class="paragrahps-2 blog this colum curses"><strong>Explanations<br></strong>Dot Product <strong><br></strong>The Cross Product  <br>Optimization: Back-face Culling  <br>Back-face Culling  <br>What is a “Normal”?  <br>Face Normals  <br>What is Light?  <br>Problems with simulating actual photons  <br>Lambertian Reflectance  <br>Specular Reflectance  <br>Basic Types of Light Sources  <br>Directional Light Formula  <br>Point Light Formula  <br>Spot Light Formula  <br>Ambient Term <br>Light Attenuation [Linear]  <br>Specular Component  <br>Adding Vertex Lighting (Gouraud Shading)  <br>Adding Per-Pixel Lighting (Phong Shading) <br>Physically Based Rendering <strong><br></strong></p>
        <p class="paragrahps-2 blog curses">‍<strong class="bold-text">Code</strong><br>Main<br>Defines<br>3D Math<br>Shaders<br>Raster Functions<strong><br></strong></p>
      </div>
    </div>
    <section id="Features" class="flex-container line w-container">
      <h2 class="heading-18"><strong>Objectives</strong></h2>
    </section>
    <div class="div-block-34 curses"><img src="../images/Raster-Surface-Stone.PNG" loading="lazy" sizes="(max-width: 1439px) 30vw, 25vw" srcset="../images/Raster-Surface-Stone-p-500.png 500w, ../images/Raster-Surface-Stone-p-800.png 800w, ../images/Raster-Surface-Stone.PNG 902w" alt="image
" class="image-19 curses"></div>
    <div class="container-7 curses w-container">
      <div class="rich-text-block-5 curses heading-curses w-richtext">
        <p>Draw star field </p>
        <p>Triangle drawing routine that supports 3D, Texturing and apply Near plane clipping</p>
        <p>Load and Draw (including texturing) indexed geometry </p>
        <p>Add Directional and Ambient lighting </p>
        <p>Add Point light with expanding/shrinking radius (includes attenuation) </p>
      </div>
    </div>
    <section id="Code" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Programming Code</strong></h2>
    </section>
    <div data-hover="false" data-delay="0" class="dropdown-2 curses w-dropdown">
      <div data-w-id="3d85396c-e759-1a32-368c-1ce1209db86d" class="dropdown-toggle-2 w-dropdown-toggle">
        <div data-w-id="3d85396c-e759-1a32-368c-1ce1209db86e" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Main</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="code-text"><strong>‍</strong>int main() <br>{ <br>RS_Initialize(RWIDTH, RHEIGHT); VERTEXES4D stars[3000];<br> for (size_t i = 0; i &lt; 3000; i++)<br> {<br> stars[i] = { Random(-1,1)*50, Random(-1,1)*50, Random(-1,1) * 50, 1 };<br> }<br> MATRIX_4X4 cam = matrixmultiply(matrixtranslation(0, 0, -6.0f), rotateX(-18.0f));<br> MATRIX_4X4 temp; unsigned int red = 0xFFFF0000; XTime timer; do<br> {<br> clear(RWIDTH * RHEIGHT);<br> //std::fill_n(ZBuffer, RPIXELS, 1);<br> timer.Signal();<br> if (GetAsyncKeyState(&#x27;W&#x27;) &amp; 0x1) {<br> temp = matrixtranslation(0, 0, 0.5f * timer.Delta());<br> cam = matrixmultiply(temp, cam);<br> }<br> <br> if (GetAsyncKeyState(&#x27;S&#x27;) &amp; 0x1) {<br> temp = matrixtranslation(0, 0, -0.5f * timer.Delta());<br> cam = matrixmultiply(temp, cam);<br> }<br> <br> if (GetAsyncKeyState(&#x27;D&#x27;) &amp; 0x1) {<br> temp = matrixtranslation(0.5f * timer.Delta(), 0, 0);<br> cam = matrixmultiply(temp, cam);<br> }<br> <br> if (GetAsyncKeyState(&#x27;A&#x27;) &amp; 0x1) {<br> temp = matrixtranslation(-0.5f * timer.Delta(), 0, 0);<br> cam = matrixmultiply(temp, cam);<br> }<br> if (GetAsyncKeyState(VK_SPACE) &amp; 0x1) {<br> temp = matrixtranslation(0, 0.5f * timer.Delta(), 0);<br> cam = matrixmultiply(temp, cam);<br> }<br> if (GetAsyncKeyState(VK_LSHIFT) &amp; 0x1) {<br> temp = matrixtranslation(0, -0.5f * timer.Delta(), 0);<br> cam = matrixmultiply(temp, cam);<br> }<br> LightRadius = std::abs(cos(timer.TotalTime())) * 2 + 0.25f;<br> VertexShader = VS_World;<br> PixelShader = PS_White; SV_WorldMatrix = identity(); viewmatrix = inverse(cam); projectmatrix = project(RWIDTH/RHEIGHT, nearPlane, farPlane, 90.0f);<br> for (size_t i = 0; i &lt; 3000; i++)<br> {<br> DrawStar(stars[i]);<br> }<br> GettingtheVertices();<br> DrawStoneHenge();<br> } while (RS_Update(raster, RPIXELS)); RS_Shutdown(); return 0;<br>}<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="3d85396c-e759-1a32-368c-1ce1209db8dd" class="dropdown-toggle-2 w-dropdown-toggle">
        <div data-w-id="3d85396c-e759-1a32-368c-1ce1209db8de" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Defines</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="code-text"><strong>‍</strong>#define farPlane 100.0f<br>#define nearPlane 0.1f#define RWIDTH 900<br>#define RHEIGHT 700<br>#define RPIXELS ((RWIDTH)*(RHEIGHT))unsigned int raster[RPIXELS] = { 0 };<br>float ZBuffer[RPIXELS] = { 100 };<br><br>struct VERTEXES<br>{<br> float x, y, z;<br>};<br>‍<br>struct VERTEXES4D <br>{<br> float x, y, z, w, u, v;<br> float nx, ny, nz;<br> unsigned int color;<br>};<br>‍<br>struct TRIANGLE_3D<br>{<br> VERTEXES4D a, b, c;<br>};<br>‍<br>VERTEXES4D stone[1457];<br><br>void GettingtheVertices() {<br> for (size_t i = 0; i &lt; 1457; i++)<br> {<br> stone[i].x = StoneHenge_data[i].pos[0] * 0.1f;<br> stone[i].y = StoneHenge_data[i].pos[1] * 0.1f;<br> stone[i].z = StoneHenge_data[i].pos[2] * 0.1f;<br> stone[i].w = 1.0f;<br> stone[i].u = StoneHenge_data[i].uvw[0];<br> stone[i].v = StoneHenge_data[i].uvw[1];<br> stone[i].nx = StoneHenge_data[i].nrm[0];<br> stone[i].ny = StoneHenge_data[i].nrm[1];<br> stone[i].nz = StoneHenge_data[i].nrm[2];<br> }<br>}<br><br>VERTEXES4D sunlightDirection = { -0.577, -0.577, 0.577 };<br>unsigned int sunColor = 0xFFC0C0F0;VERTEXES4D pointLight = { -1, 0.5, 1 };<br>unsigned int pointLightColor = 0xFFFFFF00;<br>float LightRadius = 2.0f;<br>‍<br>struct MATRIX {<br> union { struct{<br> float x1, y1, z1;<br> float x2, y2, z2;<br> float x3, y3, z3;<br> };<br> float arr[3][3];<br> };<br>};<br>‍<br>struct MATRIX_4X4 {<br> union { struct {<br> float x1, y1, z1, w1;<br> float x2, y2, z2, w2;<br> float x3, y3, z3, w3;<br> float x4, y4, z4, w4;<br> };<br> float arr[4][4];<br> };<br>};<br>‍<br>struct CUBE<br>{<br> union { struct {<br> TRIANGLE_3D bt1;<br> TRIANGLE_3D bt2;<br> TRIANGLE_3D t1, t2;<br> TRIANGLE_3D l1, l2;<br> TRIANGLE_3D r1, r2;<br> TRIANGLE_3D fw1, fw2;<br> TRIANGLE_3D ba1, ba2;<br> };<br> TRIANGLE_3D arr[2][6];<br> };<br>};<br>‍<br>struct LINE <br>{<br> VERTEXES4D a, b;<br>};<br>‍<br>struct GRID <br>{<br> union { struct {<br> LINE a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11; <br> LINE h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11; <br> }; LINE arr[11][2];<br> };<br>};<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="3d85396c-e759-1a32-368c-1ce1209db9a0" class="dropdown-toggle-2 w-dropdown-toggle">
        <div data-w-id="3d85396c-e759-1a32-368c-1ce1209db9a1" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">3D Math</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="code-text"><strong>‍</strong>float Bary(float a, float b, float c, VERTEXES4D ratios) <br>{ <br>      return a * ratios.x + b * ratios.y + c * ratios.z;<br>}<br>‍<br>float Random(float min, float max) {<br> float ratio = rand() / (float)RAND_MAX;<br> return (max - min) * ratio + min;<br>}<br>float ile(VERTEXES a, VERTEXES b, VERTEXES p)<br>{<br> return (a.y - b.y) * p.x + (b.x - a.x) * p.y + (a.x * b.y) - (a.y * b.x);<br>}<br>‍<br>int find(int x, int y, int screenWidth)<br>{<br> return (y * screenWidth + x);<br>}<br>‍<br>float lerpline(int y1, int y2, float ratio)<br>{<br> return static_cast&lt;float&gt;(y1) + (ratio * static_cast&lt;float&gt;(y2 - y1));<br>}<br>‍<br>float ImplicitLineEquation(VERTEXES4D a, VERTEXES4D b, VERTEXES4D p)<br>{<br> float answer = (a.y - b.y) * p.x + (b.x - a.x) * p.y + (a.x * b.y) - (a.y * b.x);<br> return answer;<br>}<br>‍<br>float LerpLine(float y1, float y2, float ratio) {<br> return (y1)+(ratio * (y2 - y1));<br>}<br>‍<br>float dot(VERTEXES4D a, VERTEXES4D b)<br>{<br> return a.x * b.x + a.y * b.y + a.z * b.z;<br>}<br>‍<br>VERTEXES4D cross(VERTEXES4D a, VERTEXES4D b)<br>{<br> VERTEXES4D vec = { a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x };<br> return vec;<br>}<br>‍<br>float vlength(VERTEXES4D vec)<br>{<br> return sqrtf(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);<br>}<br>‍<br>VERTEXES4D NormalizeVector(VERTEXES4D vec) {<br> float magnitude = vlength(vec);<br> if (magnitude != 0)<br> {<br> vec.x /= magnitude;<br> vec.y /= magnitude;<br> vec.z /= magnitude;<br> }<br> else<br> vec.x = vec.y = vec.z = 0.0f; return vec;<br>}<br>‍<br>float saturate(float v) {<br> if (v &gt; 1)<br> return 1;<br> else if (v &lt; 0)<br> return 0;<br> else<br> return v;<br>}<br>‍<br>unsigned int addcolors(unsigned int A, unsigned int B )<br>{<br> int Aa = ((A &amp; 0xFF000000) &gt;&gt; 24) / 255.0f;<br> int Ar = ((A &amp; 0x00FF0000) &gt;&gt; 16) / 255.0f;<br> int Ag = ((A &amp; 0x0000FF00) &gt;&gt; 8 )/ 255.0f;<br> int Ab = (A &amp; 0x000000FF) / 255.0f;<br> int Ba = ((B &amp; 0xFF000000) &gt;&gt; 24) / 255.0f;<br> int Br = ((B &amp; 0x00FF0000) &gt;&gt; 16) / 255.0f;<br> int Bg = ((B &amp; 0x0000FF00) &gt;&gt; 8) / 255.0f;<br> int Bb = (B &amp; 0x000000FF) / 255.0f;<br> unsigned int fa = static_cast&lt;unsigned&gt;(saturate(Aa + Ba) * 255) &lt;&lt; 24;<br> unsigned int fr = static_cast&lt;unsigned&gt;(saturate(Ar + Br) * 255) &lt;&lt; 16;<br> unsigned int fg = static_cast&lt;unsigned&gt;(saturate(Ag + Bg) * 255) &lt;&lt; 8;<br> unsigned int fb = static_cast&lt;unsigned&gt;(saturate(Ab + Bb) * 255);<br> return (fa | fr | fg | fb);<br>}<br>‍<br>unsigned int multiplycolors(unsigned int A, unsigned int B)<br>{<br> float Aa = ((A &amp; 0xFF000000) &gt;&gt; 24) / 255.0f;<br> float Ar = ((A &amp; 0x00FF0000) &gt;&gt; 16) / 255.0f;<br> float Ag = ((A &amp; 0x0000FF00) &gt;&gt; 8) / 255.0f;<br> float Ab = ((A &amp; 0x000000FF)) / 255.0f;<br> float Ba = ((B &amp; 0xFF000000) &gt;&gt; 24) / 255.0f;<br> float Br = ((B &amp; 0x00FF0000) &gt;&gt; 16) / 255.0f;<br> float Bg = ((B &amp; 0x0000FF00) &gt;&gt; 8) / 255.0f;<br> float Bb = (B &amp; 0x000000FF) / 255.0f; float finala = Aa + Ba;<br> float finalr = Ar + Br;<br> float finalg = Ag + Bg;<br> float finalb = Ab + Bb; if (finala &gt; 1)<br> finala = 1;<br> if (finala &lt; 0)<br> finala = 0;<br> if (finalb &gt; 1)<br> finalb = 1;<br> if (finalb &lt; 0)<br> finalb = 0;<br> if (finalr &gt; 1)<br> finalr = 1;<br> if (finalr &lt; 0)<br> finalr = 0;<br> if (finalg &gt; 1)<br> finalg = 1;<br> if (finalg &lt; 0)<br> finalg = 0; unsigned int fa = static_cast&lt;unsigned&gt;(finala * 255) &lt;&lt; 24;<br> unsigned int fr = static_cast&lt;unsigned&gt;(finalr * 255) &lt;&lt; 16;<br> unsigned int fg = static_cast&lt;unsigned&gt;(finalg * 255) &lt;&lt; 8;<br> unsigned int fb = static_cast&lt;unsigned&gt;(finalb * 255);<br> return (fa | fr | fg | fb);<br>}<br>‍<br>unsigned int ColorLerp(unsigned int A, unsigned int B, float ratio)<br> { unsigned int Aalpha = (A &amp; 0xFF000000) &gt;&gt; 24;<br> unsigned int Ared = (A &amp; 0x00FF0000) &gt;&gt; 16;<br> unsigned int Agreen = (A &amp; 0x0000FF00) &gt;&gt; 8;<br> unsigned int Ablue = (A &amp; 0x000000FF);<br> unsigned int Balpha = (B &amp; 0xFF000000) &gt;&gt; 24;<br> unsigned int Bred = (B &amp; 0x00FF0000) &gt;&gt; 16;<br> unsigned int Bgreen = (B &amp; 0x0000FF00) &gt;&gt; 8;<br> unsigned int Bblue = (B &amp; 0x000000FF); unsigned int Falpha = (static_cast&lt;int&gt;(Balpha) - static_cast&lt;int&gt;(Aalpha)) * ratio + Aalpha;<br> unsigned int Fred = (static_cast&lt;int&gt;(Bred) - static_cast&lt;int&gt;(Ared)) * ratio + Ared;<br> unsigned int Fgreen = (static_cast&lt;int&gt;(Bgreen) - static_cast&lt;int&gt;(Agreen)) * ratio + Agreen;<br> unsigned int Fblue = (static_cast&lt;int&gt;(Bblue) - static_cast&lt;int&gt;(Ablue)) * ratio + Ablue; return ((Falpha &lt;&lt; 24) | (Fred &lt;&lt; 16) | (Fgreen &lt;&lt; 8) | (Fblue));<br>}<br><br>VERTEXES4D FindBary(VERTEXES4D a, VERTEXES4D b, VERTEXES4D c, VERTEXES4D point) { unsigned int returnColor = 0xFF000000; float beta = ImplicitLineEquation(a, c, b);<br> float gamma = ImplicitLineEquation(b, a, c);<br> float alpha = ImplicitLineEquation(c, b, a);<br> float bLine = ImplicitLineEquation(a, c, point);<br> float yLine = ImplicitLineEquation(b, a, point);<br> float aLine = ImplicitLineEquation(c, b, point); VERTEXES4D P = { (aLine / alpha), (bLine / beta), (yLine / gamma) }; return P;<br>}<br>‍<br>VERTEXES vertexmatrixmultiply(VERTEXES v, MATRIX m)<br>{<br> VERTEXES t;<br> t.x = (v.x * m.x1) + (v.y * m.x2) + (v.z * m.x3);<br> t.y = (v.x * m.y1) + (v.y * m.y2) + (v.z * m.y3);<br> t.z = (v.x * m.z1) + (v.y * m.z2) + (v.z * m.z3);<br> return t;<br>}<br>‍<br>VERTEXES4D vertexmatrixmultiply(VERTEXES4D v, MATRIX_4X4 m) <br>{<br> VERTEXES4D t;<br> t.x = (v.x * m.x1) + (v.y * m.x2) + (v.z * m.x3) + (v.w * m.x4);<br> t.y = (v.x * m.y1) + (v.y * m.y2) + (v.z * m.y3) + (v.w * m.y4);<br> t.z = (v.x * m.z1) + (v.y * m.z2) + (v.z * m.z3) + (v.w * m.z4);<br> t.w = (v.x * m.w1) + (v.y * m.w2) + (v.z * m.w3) + (v.w * m.w4);<br> t.u = v.u;<br> t.v = v.v;<br> t.nx = v.nx;<br> t.ny = v.ny;<br> t.nz = v.nz;<br> t.color = v.color;<br> return t;<br>}<br>‍<br>MATRIX_4X4 identity() <br>{<br> MATRIX_4X4 t = { 0 };<br> t.x1 = 1;<br> t.y2 = 1;<br> t.z3 = 1;<br> t.w4 = 1;<br> return t;<br>}<br>‍<br>MATRIX matrixmultiply(MATRIX m1, MATRIX m2)<br>{<br> MATRIX t = { 0 };<br> t.x1 = (m1.x1 * m2.x1) + (m1.y1 * m2.x2) + (m1.z1 * m2.x3);<br> t.y1 = (m1.x1 * m2.y1) + (m1.y1 * m2.y2) + (m1.z1 * m2.y3);<br> t.z1 = (m1.x1 * m2.z1) + (m1.y1 * m2.z2) + (m1.z1 * m2.z3);<br> t.x2 = (m1.x2 * m2.x1) + (m1.y2 * m2.x2) + (m1.z2 * m2.x3);<br> t.y2 = (m1.x2 * m2.y1) + (m1.y2 * m2.y2) + (m1.z2 * m2.y3);<br> t.z2 = (m1.x2 * m2.z1) + (m1.y2 * m2.z2) + (m1.z2 * m2.z3);<br> t.x3 = (m1.x3 * m2.x1) + (m1.y3 * m2.x2) + (m1.z3 * m2.x3);<br> t.y3 = (m1.x3 * m2.y1) + (m1.y3 * m2.y2) + (m1.z3 * m2.y3);<br> t.z3 = (m1.x3 * m2.z1) + (m1.y3 * m2.z2) + (m1.z3 * m2.z3);<br> return t;<br>}<br>‍<br>MATRIX_4X4 matrixmultiply(MATRIX_4X4 m1, MATRIX_4X4 m2) <br>{<br> MATRIX_4X4 t = { 0 };<br> t.x1 = (m1.x1 * m2.x1) + (m1.y1 * m2.x2) + (m1.z1 * m2.x3) + (m1.w1 * m2.x4);<br> t.y1 = (m1.x1 * m2.y1) + (m1.y1 * m2.y2) + (m1.z1 * m2.y3) + (m1.w1 * m2.y4);<br> t.z1 = (m1.x1 * m2.z1) + (m1.y1 * m2.z2) + (m1.z1 * m2.z3) + (m1.w1 * m2.z4);<br> t.w1 = (m1.x1 * m2.w1) + (m1.y1 * m2.w2) + (m1.z1 * m2.w3) + (m1.w1 * m2.w4);<br> t.x2 = (m1.x2 * m2.x1) + (m1.y2 * m2.x2) + (m1.z2 * m2.x3) + (m1.w2 * m2.x4);<br> t.y2 = (m1.x2 * m2.y1) + (m1.y2 * m2.y2) + (m1.z2 * m2.y3) + (m1.w2 * m2.y4);<br> t.z2 = (m1.x2 * m2.z1) + (m1.y2 * m2.z2) + (m1.z2 * m2.z3) + (m1.w2 * m2.z4);<br> t.w2 = (m1.x2 * m2.w1) + (m1.y2 * m2.w2) + (m1.z2 * m2.w3) + (m1.w2 * m2.w4);<br> t.x3 = (m1.x3 * m2.x1) + (m1.y3 * m2.x2) + (m1.z3 * m2.x3) + (m1.w3 * m2.x4);<br> t.y3 = (m1.x3 * m2.y1) + (m1.y3 * m2.y2) + (m1.z3 * m2.y3) + (m1.w3 * m2.y4);<br> t.z3 = (m1.x3 * m2.z1) + (m1.y3 * m2.z2) + (m1.z3 * m2.z3) + (m1.w3 * m2.z4);<br> t.w3 = (m1.x3 * m2.w1) + (m1.y3 * m2.w2) + (m1.z3 * m2.w3) + (m1.w3 * m2.w4);<br> t.x4 = (m1.x4 * m2.x1) + (m1.y4 * m2.x2) + (m1.z4 * m2.x3) + (m1.w4 * m2.x4);<br> t.y4 = (m1.x4 * m2.y1) + (m1.y4 * m2.y2) + (m1.z4 * m2.y3) + (m1.w4 * m2.y4);<br> t.z4 = (m1.x4 * m2.z1) + (m1.y4 * m2.z2) + (m1.z4 * m2.z3) + (m1.w4 * m2.z4);<br> t.w4 = (m1.x4 * m2.w1) + (m1.y4 * m2.w2) + (m1.z4 * m2.w3) + (m1.w4 * m2.w4);<br> return t; <br>}<br>‍<br>MATRIX_4X4 matrixtranslation(float x, float y, float z) <br>{<br> MATRIX_4X4 t = identity();<br> t.x4 = x;<br> t.y4 = y;<br> t.z4 = z;<br> return t;<br>}<br>‍<br>MATRIX_4X4 rotateX(float d) <br>{<br> d = d * 3.14f / 180.0f;<br> MATRIX_4X4 t = { 0 };<br> t.y2 = cos(d);<br> t.z2 = -sin(d);<br> t.y3 = sin(d);<br> t.z3 = cos(d);<br> t.x1 = 1;<br> t.w4 = 1;<br> return t;<br>}<br>‍<br>MATRIX_4X4 rotateY(float d) <br>{<br> d = d * 3.14f / 180.0f;<br> MATRIX_4X4 t = { 0 };<br> t.x1 = cos(d);<br> t.z1 = sin(d);<br> t.x3 = -sin(d);<br> t.z3 = cos(d);<br> t.y2 = 1;<br> t.w4 = 1;<br> return t;<br>}<br>‍<br>MATRIX_4X4 rotateZ(float d)<br>{<br> d = d * 3.14f / 180.0f;<br> MATRIX_4X4 t = { 0 };<br> t.x1 = cos(d);<br> t.y1 = -sin(d);<br> t.x2 = sin(d);<br> t.y2 = cos(d);<br> t.z3 = 1;<br> return t;<br>}<br>‍<br>MATRIX_4X4 inverse(MATRIX_4X4 m) {<br> float t = m.x2;<br> m.x2 = m.y1;<br> m.y1 = t;<br> t = m.x3;<br> m.x3 = m.z1;<br> m.z1 = t;<br> t = m.y3;<br> m.y3 = m.z2;<br> m.z2 = t;<br> VERTEXES tv = { m.x4, m.y4, m.z4 };<br> MATRIX tm = { m.x1, m.y1, m.z1, m.x2, m.y2, m.z2, m.x3, m.y3, m.z3 };<br> tv = vertexmatrixmultiply(tv, tm);<br> m.x4 = tv.x * -1;<br> m.y4 = tv.y * -1;<br> m.z4 = tv.z * -1;<br> return m;<br>}<br>‍<br>MATRIX_4X4 project(float ar, float np, float fp, float fov) {<br> float Ys = 1 / tan((fov / 2) * 3.141592f / 180);<br> float Xs = Ys * ar;<br> MATRIX_4X4 t =<br> {<br>   Xs, 0, 0, 0 , 0, Ys, 0, 0, 0, 0, fp / (fp - np), 1,   0, 0, -(fp * np) / (fp - np), 0<br> };<br> return t;<br>}<br>‍<br>VERTEXES btopixel(VERTEXES v)<br>{<br> v.x = floor((v.x + 1) * (RWIDTH / 2));<br> v.y = floor((1 - v.y) * (RHEIGHT / 2));<br> return v;<br>}<br>VERTEXES4D btopixel(VERTEXES4D v) <br>{<br> v.x = floor((v.x + 1) * (RWIDTH / 2));<br> v.y = floor((1 - v.y) * (RHEIGHT / 2));<br> return v;<br>}<br>‍<br>TRIANGLE_3D triangletopixel(TRIANGLE_3D&amp; tri) { tri.a = btopixel(tri.a); tri.b = btopixel(tri.b);<br> tri.c = btopixel(tri.c);<br> return tri;<br>}<br>‍<br>CUBE cubetopixel(CUBE c) <br>{<br> c.bt1 = triangletopixel(c.bt1);<br> c.bt2 = triangletopixel(c.bt2);<br> c.ba1 = triangletopixel(c.ba1);<br> c.ba2 = triangletopixel(c.ba2);<br> c.t1 = triangletopixel(c.t1);<br> c.t2 = triangletopixel(c.t2);<br> c.fw1 = triangletopixel(c.fw1);<br> c.fw2 = triangletopixel(c.fw2);<br> c.l1 = triangletopixel(c.l1);<br> c.l2 = triangletopixel(c.l2); return c;<br>}<br>‍<br>GRID gridtopixel(GRID g) <br>{<br> for (size_t i = 0; i &lt; 11; i++)<br> {<br> for (size_t j = 0; j &lt; 2; j++)<br> {<br> g.arr[i][j].b = btopixel(g.arr[i][j].b);<br> g.arr[i][j].a = btopixel(g.arr[i][j].a); }<br> }<br> return g;<br>}<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="3d85396c-e759-1a32-368c-1ce1209dbc06" class="dropdown-toggle-2 w-dropdown-toggle">
        <div data-w-id="3d85396c-e759-1a32-368c-1ce1209dbc07" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Shaders</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog"><strong>‍</strong>void (*VertexShader)(VERTEXES4D&amp;) = 0;<br>void (*PixelShader)(unsigned int&amp;) = 0;<br>MATRIX_4X4 SV_WorldMatrix;<br>MATRIX_4X4 viewmatrix;<br>MATRIX_4X4 projectmatrix;void VS_World(VERTEXES4D&amp; multiplyMe)<br>{<br>   <br>    multiplyMe = vertexmatrixmultiply(multiplyMe, SV_WorldMatrix);<br>    VERTEXES4D copy = multiplyMe;<br>    multiplyMe = vertexmatrixmultiply(multiplyMe, viewmatrix);<br>    multiplyMe = vertexmatrixmultiply(multiplyMe, projectmatrix);<br>    VERTEXES4D normal = { multiplyMe.nx, multiplyMe.ny, multiplyMe.nz };<br>        normal = NormalizeVector(normal);        VERTEXES4D dir = { -sunlightDirection.x, -sunlightDirection.y, -sunlightDirection.z };<br>        dir = NormalizeVector(dir);        float dotdot = dot(dir, normal);<br>        float lightRatio = saturate(dotdot);        unsigned int result = ColorLerp(0xFF000000, sunColor, lightRatio);<br>        VERTEXES4D pointdir = { (pointLight.x - copy.x), (pointLight.y - copy.y), (pointLight.z - copy.z) };        float attenuation = 1 - saturate(vlength(pointdir) / LightRadius);        pointdir = NormalizeVector(pointdir);        dotdot = dot(pointdir, normal);<br>        lightRatio = saturate(dotdot) * attenuation;<br>        unsigned int pointresult = ColorLerp(0xFF000000, pointLightColor, lightRatio);<br>        multiplyMe.color = addcolors(result, pointresult);<br>    /*multiplyMe.x = multiplyMe.x / multiplyMe.w;<br>    multiplyMe.y = multiplyMe.y / multiplyMe.w;<br>    multiplyMe.z = multiplyMe.z / multiplyMe.w;*/<br>}<br>void PS_White(unsigned int&amp; color) <br>{<br>    color = 0xFFFFFFFF;<br>}<br>void PS_Green(unsigned int&amp; color) <br>{<br>    color = 0xFF00FF00;<br>}<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="3d85396c-e759-1a32-368c-1ce1209dbc4e" class="dropdown-toggle-2 w-dropdown-toggle">
        <div data-w-id="3d85396c-e759-1a32-368c-1ce1209dbc4f" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Raster Funtions</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog"><strong>‍</strong>void PerspectiveDivide(VERTEXES4D&amp; multiplyMe) {<br> multiplyMe.x /= multiplyMe.w;<br> multiplyMe.y /= multiplyMe.w;<br> multiplyMe.z /= multiplyMe.w;<br>}<br>void clear(int totalPixelsOnScreen) {<br> for (int i = 0; i &lt; totalPixelsOnScreen; i++)<br> {<br> raster[i] = 0x00000000;<br> ZBuffer[i] = 1;<br> }<br>}<br>void dpixel(int x, int y, float z, int screenWidth, unsigned int color) {<br> if (x &gt;= RWIDTH || x &lt; 0 || y &gt;= RHEIGHT || y &lt; 0)<br> return;<br> float comparer = ZBuffer[find(x, y, screenWidth)];<br> if (z &lt; comparer)<br> {<br> raster[find(x, y, screenWidth)] = color;<br> ZBuffer[find(x, y, screenWidth)] = z;<br> }}<br>void DrawStar(VERTEXES4D vec) { VERTEXES4D copy = vec;<br> if (VertexShader)<br> VertexShader(copy); if (vec.z &lt; nearPlane)<br> return; PerspectiveDivide(copy); VERTEXES4D fVec = btopixel(copy); unsigned int color = 0xFFFFFFFF;<br> if (PixelShader)<br> PixelShader(color); dpixel(fVec.x, fVec.y, fVec.z, RWIDTH, color);}unsigned int BGRAtoARGB(unsigned int color) { unsigned int Tgreen;<br> unsigned int Tred;<br> unsigned int Tblue;<br> unsigned int Talpha; Tblue = (color &amp; 0xFF000000) &gt;&gt; 24;<br> Tgreen = (color &amp; 0x00FF0000) &gt;&gt; 8;<br> Tred = (color &amp; 0x0000FF00) &lt;&lt; 8;<br> Talpha = (color &amp; 0x000000FF) &lt;&lt; 24; return Talpha | Tred | Tgreen | Tblue;<br>}unsigned int berpC(unsigned int A, unsigned int B, unsigned int C, VERTEXES4D r)<br>{<br> int Aa = (A &amp; 0xFF000000) &gt;&gt; 24;<br> int Ar = (A &amp; 0x00FF0000) &gt;&gt; 16;<br> int Ag = (A &amp; 0x0000FF00) &gt;&gt; 8;<br> int Ab = (A &amp; 0x000000FF);<br> int Ba = (B &amp; 0xFF000000) &gt;&gt; 24;<br> int Br = (B &amp; 0x00FF0000) &gt;&gt; 16;<br> int Bg = (B &amp; 0x0000FF00) &gt;&gt; 8;<br> int Bb = (B &amp; 0x000000FF);<br> int Ca = (C &amp; 0xFF000000) &gt;&gt; 24;<br> int Cr = (C &amp; 0x00FF0000) &gt;&gt; 16;<br> int Cg = (C &amp; 0x0000FF00) &gt;&gt; 8;<br> int Cb = (C &amp; 0x000000FF);<br> unsigned int fa = ((Aa)*r.x + (Ba)*r.y + (Ca)*r.z);<br> unsigned int fr = ((Ar)*r.x + (Br)*r.y + (Cr)*r.z);<br> unsigned int fg = ((Ag)*r.x + (Bg)*r.y + (Cg)*r.z);<br> unsigned int fb = ((Ab)*r.x + (Bb)*r.y + (Cb)*r.z);<br> fa = (fa &lt;&lt; 24);<br> fr = (fr &lt;&lt; 16);<br> fg = (fg &lt;&lt; 8);<br> return (fa | fr | fg | fb);<br>}void FillTriangle(const TRIANGLE_3D&amp; tri) {<br> int minX = std::min(tri.a.x, std::min(tri.b.x, tri.c.x));<br> int maxX = std::max(tri.a.x, std::max(tri.b.x, tri.c.x)); int minY = std::min(tri.a.y, std::min(tri.b.y, tri.c.y));<br> int maxY = std::max(tri.a.y, std::max(tri.b.y, tri.c.y)); for (int y = minY; y &lt;= maxY; ++y)<br> {<br> for (int x = minX; x &lt;= maxX; ++x)<br> {<br> VERTEXES4D p = { static_cast&lt;float&gt;(x), static_cast&lt;float&gt;(y) };<br> VERTEXES4D temp = FindBary(tri.a, tri.b, tri.c, p);<br> if (temp.x &gt;= 0 &amp;&amp; temp.x &lt;= 1 &amp;&amp; temp.y &gt;= 0 &amp;&amp; temp.y &lt;= 1 &amp;&amp; temp.z &gt;= 0 &amp;&amp; temp.z &lt;= 1) {<br> float z = tri.a.z * temp.x + tri.b.z * temp.y + tri.c.z * temp.z;<br> float u = Bary((tri.a.u / tri.a.w), (tri.b.u / tri.b.w), (tri.c.u / tri.c.w), temp);<br> float v = Bary((tri.a.v / tri.a.w), (tri.b.v / tri.b.w), (tri.c.v / tri.c.w), temp);<br> float bar = Bary((1 / tri.a.w), (1 / tri.b.w), (1 / tri.c.w), temp); <br> u = u / bar;<br> v = v / bar;<br> int mipLevel = ((z - nearPlane) / (farPlane - nearPlane)) * StoneHenge_numlevels;<br> int newWidth = StoneHenge_width &gt;&gt; mipLevel;<br> int newHeight = StoneHenge_height &gt;&gt; mipLevel; unsigned int offset = StoneHenge_leveloffsets[mipLevel]; float pixelX = (u * newWidth);<br> float pixelY = (v * newHeight); int index = static_cast&lt;int&gt;(pixelX) + static_cast&lt;int&gt;(pixelY) * newWidth; unsigned int topLeft = StoneHenge_pixels[index + offset];<br> unsigned int topRight = StoneHenge_pixels[index + 1 + offset];<br> unsigned int botLeft = StoneHenge_pixels[index + newWidth + offset];<br> unsigned int botRight = StoneHenge_pixels[index + newWidth + 1 + offset]; float ratioX = pixelX - floorf(pixelX);<br> float ratioY = pixelY - floorf(pixelY);<br> unsigned int avTop = ColorLerp(topLeft, topRight, ratioX);<br> unsigned int avBot = ColorLerp(botLeft, botRight, ratioX);<br> unsigned int finalPixel = ColorLerp(avTop, avBot, ratioY); unsigned int baryColor = berpC(tri.a.color, tri.b.color, tri.c.color, temp);<br> unsigned int actuallyFinal = multiplycolors(baryColor, BGRAtoARGB(finalPixel));<br> dpixel(x, y, z, RWIDTH, actuallyFinal);<br> }<br> }<br> }<br>}<br>int ClipLineNearPlane(VERTEXES4D&amp; a, VERTEXES4D&amp; b) { if (a.z &gt; nearPlane &amp;&amp; b.z &gt; nearPlane)<br> return 1;  <br> if (a.z &lt; nearPlane &amp;&amp; b.z &lt; nearPlane)<br> return -1; <br> if (a.z &lt; nearPlane) {<br> float ratio = (nearPlane - a.z) / (b.z - a.z);<br> a.x = LerpLine(a.x, b.x, ratio);<br> a.y = LerpLine(a.y, b.y, ratio);<br> a.z = LerpLine(a.z, b.z, ratio);<br> a.w = LerpLine(a.w, b.w, ratio);<br> a.u = LerpLine(a.u, b.u, ratio);<br> a.v = LerpLine(a.v, b.v, ratio);<br> }<br> if (b.z &lt; nearPlane) {<br> float ratio = (nearPlane - b.z) / (a.z - b.z);<br> b.x = LerpLine(b.x, a.x, ratio);<br> b.y = LerpLine(b.y, a.y, ratio);<br> b.z = LerpLine(b.z, a.z, ratio);<br> b.w = LerpLine(b.w, a.w, ratio);<br> b.u = LerpLine(b.u, a.u, ratio);<br> b.v = LerpLine(b.v, a.v, ratio);<br> } return 0;<br>}<br>int ClipTriangleNearPlane(VERTEXES4D&amp; a, VERTEXES4D&amp; b, VERTEXES4D&amp; c, VERTEXES4D&amp; d) { if (a.z &gt; nearPlane &amp;&amp; b.z &gt; nearPlane &amp;&amp; c.z &gt; nearPlane) {<br> return -1;<br> }<br> if (a.z &lt; nearPlane &amp;&amp; b.z &lt; nearPlane &amp;&amp; c.z &lt; nearPlane) {<br> return 0;<br> } VERTEXES4D lineAB[2] = { a, b };<br> VERTEXES4D lineBC[2] = { b, c };<br> VERTEXES4D lineCA[2] = { c, a }; int results[3] = {<br> ClipLineNearPlane(lineAB[0], lineAB[1]),<br> ClipLineNearPlane(lineBC[0], lineBC[1]),<br> ClipLineNearPlane(lineCA[0], lineCA[1])<br> }; if (results[0] == -1)<br> {<br> a = lineCA[1];<br> b = lineBC[0];<br> c = c;<br> return 1;<br> }<br> if (results[0] == 1)<br> {<br> a = a;<br> b = b;<br> c = lineBC[1];<br> d = lineCA[0];<br> return 2;<br> }<br> if (results[1] == -1)<br> {<br> a = a;<br> b = lineAB[1];<br> c = lineCA[0];<br> return 1;<br> } if (results[1] == 1)<br> {<br> a = lineAB[0];<br> b = b;<br> c = c;<br> d = lineCA[1];<br> return 2;<br> } if (results[2] == -1)<br> {<br> a = lineAB[0];<br> b = b;<br> c = lineBC[1];<br> return 1;<br> } if (results[2] == 1)<br> {<br> a = a;<br> b = lineAB[1];<br> d = c;<br> c = lineBC[0];<br> return 2;<br> }<br>}<br>void DrawTriangle(const TRIANGLE_3D&amp; triangle) { TRIANGLE_3D copyTri = triangle; if (VertexShader) {<br> VertexShader(copyTri.a);<br> VertexShader(copyTri.b);<br> VertexShader(copyTri.c);<br> }<br> VERTEXES4D d;<br> int answer = ClipTriangleNearPlane(copyTri.a, copyTri.b, copyTri.c, d); if (answer == 0)<br> return;<br> PerspectiveDivide(copyTri.a);<br> PerspectiveDivide(copyTri.b);<br> PerspectiveDivide(copyTri.c);<br> PerspectiveDivide(d);<br> TRIANGLE_3D tri = triangletopixel(copyTri);<br> TRIANGLE_3D secondTri = { copyTri.a, copyTri.c, d };<br> TRIANGLE_3D sTri = triangletopixel(secondTri); FillTriangle(tri); if (answer &gt;= 2) {<br> FillTriangle(sTri);<br> }<br> <br>}void ParametricLine(VERTEXES4D inia, VERTEXES4D inib, unsigned int color)<br>{<br> VERTEXES4D copya = inia;<br> VERTEXES4D copyb = inib;<br> if (VertexShader) {<br> VertexShader(copya);<br> VertexShader(copyb);<br> } if (ClipLineNearPlane(copya, copyb) == -1)<br> {<br> return;<br> } PerspectiveDivide(copya);<br> PerspectiveDivide(copyb); VERTEXES4D a = btopixel(copya);<br> VERTEXES4D b = btopixel(copyb);<br> int deltaX = std::abs(b.x - a.x);<br> int deltaY = std::abs(b.y - a.y);<br> int totalPixels = (deltaX &gt; deltaY) ? deltaX : deltaY;<br> for (int i = 0; i &lt; totalPixels; i++)<br> {<br> float R = static_cast&lt;float&gt;(i) / totalPixels;<br> int pX = static_cast&lt;int&gt;(a.x + R * (b.x - a.x) + 0.5f);<br> int pY = static_cast&lt;int&gt;(a.y + R * (b.y - a.y) + 0.5f);<br> float pZ = LerpLine(a.z, b.z, R); dpixel(pX, pY, pZ, RWIDTH, color);<br> }<br>}<br>void DrawStoneHenge() { for (int i = 0; i &lt; 2532; i += 3)<br> {<br> TRIANGLE_3D temp = { stone[StoneHenge_indicies[i]], stone[StoneHenge_indicies[i + 1]] , stone[StoneHenge_indicies[i + 2]] };<br> DrawTriangle(temp);<br> }<br>}<br></p>
        </div>
      </nav>
    </div>
    <section id="Features" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Guidance</strong></h2>
    </section>
    <div class="container-7 curses w-container">
      <div class="rich-text-curses w-richtext">
        <p>dot_product </p>
        <p> &gt; dot product between two vectors with x,y,z components </p>
        <p>cross_product </p>
        <p>  &gt; cross product between two vectors with x,y,z components </p>
        <p>vec3_normalize </p>
        <p>  &gt; normalize a vector with x,y,z components </p>
        <p>combine_colors </p>
        <p>  &gt; additively combine two colors </p>
        <p>modulate_colors </p>
        <p>  &gt; multiplicatively combine two colors </p>
        <p>saturate </p>
        <p>  &gt; clamps a value between 0 and 1 </p>
        <p>vec3_length</p>
        <p>  &gt; computes the vectors length </p>
        <p>‍</p>
        <p>Here are some important values for your lights before we begin the lighting routine.   </p>
        <p>Directional Light: direction = -0.577, -0.577, 0.577; color = 0xFFC0C0F0 </p>
        <p>Point Light: pos = -1, 0.5, 1;  color = 0xFFFFFF00 </p>
        <p>In order to do lighting we will accomplish this in the vertex shader.  We will do per-vertex lighting and store the current lighting color in the vertex’s color data member.  In the vertex shader you will transform the vertex’s position and normal into world space by multiplying them by the world matrix.</p>
      </div>
    </div>
    <section id="Features" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Programming Explanation</strong></h2>
    </section>
    <div class="container-7 curses w-container">
      <div class="rich-text-block-5 curses heading-curses w-richtext">
        <p><strong>The Dot Product</strong> </p>
        <p>Can be used to determine the relationship between two vectors of equal length.  </p>
        <p>A result of ZERO indicates the two vectors are perpendicular to one another. </p>
        <p>A result of 1 or -1 indicates the two vectors are PARALLEL to each other. </p>
        <p>It is often important to NORMALIZE vectors before calculating the Dot Product. </p>
        <p>‍</p>
        <p><strong>The Cross Product</strong> </p>
        <p>Given two 3D vectors of any length, the cross product can be used to solve a third vector that will be PERPENDICULAR to both. </p>
        <p>Notice that any two non-equivalent 3D vectors will form a plane. </p>
        <p>The Cross-Product can be used to find the GRADIENT of that plane. </p>
        <p>Both the cross product &amp; dot product will come in handy when we start to look at how light should interact with our surfaces. </p>
        <p>‍</p>
        <p><strong>Optimization: Back-face Culling</strong> </p>
        <ul role="list">
          <li>The Cross Product can be used to determine which side of a triangle is facing the screen. </li>
          <li>Through vector subtraction one may solve two planar vectors aligned with the triangle’s plane. </li>
          <li>You can then cross these vectors to find a perpendicular vector. </li>
          <li>Assuming the triangle’s plane is not perfectly parallel to the view direction, the resulting Z value of the cross product will be either positive or negative. </li>
          <li>You can then order a triangle’s vertices in a consistent fashion based on which way you wish to see them. Either “clockwise” or “counter-clockwise”. (This is known as polygon “winding”) </li>
          <li>By ignoring “Back-facing” triangles during rasterization you can boost drawing speed.     </li>
        </ul>
        <p>‍</p>
        <p><strong>Back-face Culling</strong> </p>
        <p>By winding all of our triangles based on the direction we wish to see them, it becomes possible to detect which side we are looking at using the cross product. </p>
        <p>By ignoring “hidden” triangles (such as on the opposite facing side of this cube) we can dramatically decrease time spent rasterizing surfaces that will be obscured anyway. </p>
        <p>You can add this check with only a few lines extra lines of code at the top of your triangle drawing routine. </p>
        <p>‍</p>
        <p><strong>What is a “Normal”?</strong> </p>
        <p>Remember the “Gradient” from lesson 2? It was a 2D vector perpendicular to the direction of a line. </p>
        <p>In a similar fashion a “Normal” is a 3D vector perpendicular to the surface of a plane. </p>
        <p>In both cases each one represents whichever direction is considered “Up” relative to that primitive. </p>
        <p>Unlike the gradient however, which can be any length. A normal is meant to be “unit length” which indicates it has a magnitude of one. </p>
        <p>A triangle’s normal can be found easily by using the cross product and then “normalizing” the resulting 3D vector. </p>
        <p>To normalize a vector simply divide each component (xyz) by the current length of the vector. </p>
        <p>‍</p>
        <p><strong>Face Normals</strong> </p>
        <p>These are the “true” normals of each primitive in a given mesh. They are calculated as previously shown. </p>
        <p>Each vertex assigned to the primitive shares this same exact normal. </p>
        <p>As you will see, normals may be used to estimate how much light a surface should receive. </p>
        <p>When used to shade a surface, they create a very “faceted” appearance, since each normal reflects the true surface geometry underneath.   </p>
        <p>‍</p>
        <p><strong>Vertex Normals</strong> </p>
        <p>Unlike face normals, vertex normals are stored independently for each vertex. </p>
        <p>Because of this, vertices on a single primitive can actually be different from one another. </p>
        <p>By averaging face normals between overlapping vertices, we can simulate smoother surfaces than we actually have access to. </p>
        <p>This comes in handy when shading surfaces that are supposed to be more smooth or organic in nature.   </p>
        <p>‍</p>
        <p><strong>What is Light?</strong> </p>
        <ul role="list">
          <li>Visible light only makes up a tiny portion of the electromagnetic spectrum. </li>
          <li>Visible/Infrared/Ultraviolet Light, X-Rays, Gamma Rays &amp; Radio Waves are all composed of Photons which interact with matter by being absorbed, reflected or refracted. </li>
          <li>Each Photon is a discrete packet of energy (depending on wavelength) traveling at the speed of light. (~3.00×108 m/s)  </li>
          <li>Different materials absorb different portions of the electromagnetic spectrum. The unabsorbed frequency is typically part of the color we perceive. </li>
          <li>A vehicle is perceived as blue because it’s paint absorbs more red &amp; green wavelength photons. This is also why a black car gets hotter in the sun than a white car. </li>
          <li>The microscopic geometry of the surface or its “roughness” also impacts on how light interacts with it. But more on that later…  </li>
        </ul>
        <p>‍</p>
        <p><strong>Problems with simulating actual photons</strong> </p>
        <ul role="list">
          <li>On a sunny day approximately 2.9x1014 photons of visible light strike one square inch in the span of a single second. </li>
          <li>The current worlds fastest supercomputer (which takes up a whole building) can only do 3.38x1013  computations in one second. </li>
          <li>Never mind the fact that a single photon would require far more than a single computation… </li>
          <li>Another problem is that our triangles are perfectly flat. Even the smoothest surfaces you encounter day to day are not perfectly flat at the microscopic level! </li>
          <li>To simulate light in real-time we will have to take some pretty massive shortcuts. Thankfully there are a number of ways to “approximate” these surface interactions. </li>
        </ul>
        <p>‍</p>
        <p><strong>Lambertian Reflectance</strong> </p>
        <p>his refection model is a simple way to approximate the behavior of a perfectly “lambertian” surface. </p>
        <p>A lambertian surface, is a material that absorbs and then randomly scatters all outgoing light rays. (perfect diffusion) </p>
        <p>A point on this surface appears to be the same luminance regardless of the angle of the observer.  </p>
        <p>This is fair approximation of the behavior of very rough or “matte” surfaces such as wood or unpainted dry clay.    </p>
        <p>‍</p>
        <p><strong>Specular Reflectance </strong></p>
        <p>Unlike lambertian reflectance, specular reflectance is designed to mimic photons bouncing off of the material’s surface before being absorbed &amp; emitted. </p>
        <p>This is an effective model for producing the various “highlights” on shiny surfaces. </p>
        <p>Generally most visual surfaces can be represented using some combination of lambetinan &amp; specular reflectance. </p>
        <p>There are of course some exceptions to this however… </p>
        <p>‍</p>
        <p><strong>Basic Types of Light Sources</strong> </p>
        <ul role="list">
          <li>Directional Light </li>
        </ul>
        <ul role="list">
          <li>Typically used to model the overhead sun/moon light from a very distant point. </li>
        </ul>
        <ul role="list">
          <li>Point Light </li>
        </ul>
        <ul role="list">
          <li>Models any Omni-directional light source such as torches, lightbulbs and explosions. </li>
        </ul>
        <ul role="list">
          <li>Spot Light </li>
        </ul>
        <ul role="list">
          <li>As the name implies, used for conical light sources such as flashlights &amp; head lights. </li>
        </ul>
        <ul role="list">
          <li>Ambient Term </li>
        </ul>
        <ul role="list">
          <li>Used to model the “indirect” lighting within a scene. In it’s most basic form simply a flat term added to all surfaces to simulate all the randomly scattered photons bouncing off of surfaces. </li>
        </ul>
        <p>‍</p>
        <p><strong>Directional Light Formula</strong> </p>
        <p><strong>LIGHTRATIO = CLAMP( DOT(         -LIGHTDIR, SURFACENORMAL ) )</strong> </p>
        <p><strong>RESULT = LIGHTRATIO * LIGHTCOLOR * SURFACECOLOR</strong> </p>
        <p><strong>Directional light sources are actually point light sources at an infinite distance. This assumption works well enough for highly distant light sources such as the Sun.</strong> </p>
        <p> </p>
        <p><strong>Point Light Formula</strong> </p>
        <p><strong>LIGHTDIR = NORMALIZE( LIGHTPOS – SURFACEPOS )</strong> </p>
        <p><strong>LIGHTRATIO = CLAMP( DOT( LIGHTDIR, SURFACENORMAL ) )</strong> </p>
        <p><strong>RESULT = LIGHTRATIO * LIGHTCOLOR * SURFACECOLOR</strong> </p>
        <p><strong>A point light emits light in all directions. To determine the specific incoming light direction for a surface, you must use vector subtraction to solve the vector between the two points.</strong> </p>
        <p> </p>
        <p><strong>Spot Light Formula</strong> </p>
        <p><strong>LIGHTDIR = NORMALIZE( LIGHTPOS – SURFACEPOS ) )</strong> </p>
        <p><strong>SURFACERATIO = CLAMP( DOT(   -LIGHTDIR, CONEDIR ) )</strong> </p>
        <p><strong>SPOTFACTOR = ( SURFACERATIO &gt; CONERATIO ) ? 1 : 0</strong> </p>
        <p><strong>LIGHTRATIO = CLAMP( DOT( LIGHTDIR, SURFACENORMAL ) )</strong> </p>
        <p><strong>RESULT = SPOTFACTOR * LIGHTRATIO * LIGHTCOLOR * SURFACECOLOR</strong> </p>
        <p> </p>
        <p><strong>The spot light is essentially a point light which has been restricted to a cone pointed in a specific direction. The dot product is used to determine if the point falls within the cone.</strong> </p>
        <p> </p>
        <p><strong>Ambient Term</strong> </p>
        <p><strong>LIGHTRATIO = </strong> </p>
        <p><strong>CLAMP( LIGHTRATIO + </strong> </p>
        <p><strong>AMBIENTTERM )</strong> </p>
        <p><strong>While far from realistic, the ambient term helps to fill in the missing sense of scattered light within a scene.</strong> </p>
        <p> </p>
        <p><strong>Different environments may have significantly different ambient terms. (ex: Cave vs Beach)</strong> </p>
        <p><strong>Light Attenuation [Linear]</strong> </p>
        <p>Falloff by Radius </p>
        <p><strong>ATTENUATION = </strong> </p>
        <p><strong>1.0 – CLAMP( MAGNITUDE( LIGHTPOS – SURFACEPOS ) / LIGHTRADIUS )</strong> </p>
        <p><strong>ATTENUATION = </strong> </p>
        <p><strong>1.0 – CLAMP( MAGNITUDE( LIGHTPOS – SURFACEPOS ) / LIGHTRADIUS )</strong> </p>
        <p>Falloff from Cone Edge </p>
        <p><strong>ATTENUATION = </strong> </p>
        <p><strong>1.0 – CLAMP( ( INNERCONERATIO – SURFACERATIO ) / ( INNERCONERATIO – OUTERCONERATIO ) ) </strong> </p>
        <p> </p>
        <p><strong>To make any falloff [Quadratic], simply multiply the attenuation by itself.</strong> </p>
        <p><strong>A quadratic curve is much closer to how lights lose energy over distance.</strong> </p>
        <p><strong>Specular Component</strong> </p>
        <p>VIEWDIR =  </p>
        <p>NORMALIZE( CAMWORLDPOS – SURFACEPOS )  </p>
        <p>HALFVECTOR =  </p>
        <p>NORMALIZE(( -LIGHTDIR ) + VIEWDIR )  </p>
        <p>INTENSITY = MAX( CLAMP( DOT( NORMAL, HALFVECTOR ))<strong>SPECULARPOWER</strong> , 0 ) </p>
        <p>REFLECTEDLIGHT = LIGHTCOLOR * SPECULARINTENSITY * INTENSITY  </p>
        <p> </p>
        <p><strong>Specular highlights represent light that is reflected from a surface to your eye. This adds an extra level of detail &amp; realism to a surface. (ADD this to a light’s lambertian result)</strong> </p>
        <p> </p>
        <p><strong>Adding Vertex Lighting (Gouraud Shading)</strong> </p>
        <ul role="list">
          <li>Step 1: </li>
        </ul>
        <ul role="list">
          <li>Add normals to your vertex structure and compute them or load them alongside other pre-built mesh data. (Normalize them if they are not already unit length) </li>
        </ul>
        <ul role="list">
          <li>Step 2: </li>
        </ul>
        <ul role="list">
          <li>Create lighting parameters accessible by your shaders. For example: A directional light might have a color &amp; normalized light direction in world space. </li>
        </ul>
        <ul role="list">
          <li>Step 3: </li>
        </ul>
        <ul role="list">
          <li>In the vertex shader use the world space vertex information (normal &amp; position) to calculate the amount of light reaching a vertex. Embed this information into the color of this vertex. </li>
        </ul>
        <ul role="list">
          <li>Step 4: </li>
        </ul>
        <ul role="list">
          <li>Use the interpolated light information within the Pixel Shader to shade the surface by multiplying the light hitting the surface by the original surface color. (Modulation) </li>
        </ul>
        <p>‍</p>
        <p><strong>Adding Per-Pixel Lighting (Phong Shading)</strong> </p>
        <ul role="list">
          <li>Step 1 &amp; 2: </li>
        </ul>
        <ul role="list">
          <li>Same as per-vertex lighting. </li>
        </ul>
        <ul role="list">
          <li>Step 3: </li>
        </ul>
        <ul role="list">
          <li>Add a “world position” variable to your vertex structure. (3 floats) </li>
        </ul>
        <ul role="list">
          <li>Step 4: </li>
        </ul>
        <ul role="list">
          <li>Instead of computing the light amount in the vertex shader, move the vertex normal into world space and “save” the world space positon into your new “world position” variable. </li>
        </ul>
        <ul role="list">
          <li>Step 5: </li>
        </ul>
        <ul role="list">
          <li>During rasterization you now interpolate both the world normal and the “world position” components of the vertex across the surface of your primitive. Send these to your Pixel Shader.  </li>
        </ul>
        <ul role="list">
          <li>Step 6: </li>
        </ul>
        <ul role="list">
          <li>At this point you know the actual position &amp; normal of each individual pixel! Compute the lighting results just like you would in the vertex shader but now with significantly more accuracy! </li>
        </ul>
        <p>‍</p>
        <p><strong>Physically Based Rendering</strong> </p>
        <p>Modern real-time computer graphics has started to embrace more physically accurate light transport models such as Cook-Torrence. </p>
        <p>Unlike models such as Blinn-Phong which are approximations based on observation, these computations are based on physical material properties and how they actually interact with light. (Dielectrics &amp; Metals) </p>
        <p>The cost of such shading, while significantly higher does produce more accurate results for a surface under a variety of different lighting conditions.</p>
        <p>‍</p>
        <p>‍</p>
      </div>
    </div>
  </div>
  <div class="section-2 footer background-black wf-section">
    <div class="container-4 w-container">
      <div class="footer-holder">
        <div class="social-wrapper">
          <a href="https://juan_diego_lugo.artstation.com" target="_blank" class="social-link w-inline-block"><img src="../images/Artstation.png" loading="lazy" alt="" class="image-13"></a>
          <a href="https://github.com/JDMAXilius" target="_blank" class="social-link w-inline-block"><img src="../images/github.png" loading="lazy" alt="image" class="image-13"></a>
          <a href="https://www.youtube.com/channel/UCRjr5hvDeIpc_SfgTO690RA/featured" target="_blank" class="social-link w-inline-block"><img src="../images/youtube.png" loading="lazy" alt="" class="image-13"></a>
          <a href="#" class="social-link w-inline-block"><img src="../images/pngfind.com-discord-icon-png-283551.png" loading="lazy" sizes="(max-width: 479px) 50vw, 40px" srcset="../images/pngfind.com-discord-icon-png-283551-p-500.png 500w, ../images/pngfind.com-discord-icon-png-283551-p-800.png 800w, ../images/pngfind.com-discord-icon-png-283551-p-1080.png 1080w, ../images/pngfind.com-discord-icon-png-283551.png 1468w" alt="" class="image-13"></a>
          <a href="https://www.facebook.com/juandiego.lugo1" target="_blank" class="social-link w-inline-block"><img src="../images/fb.png" loading="lazy" alt="" class="image-13 f"></a>
          <a href="#" class="social-link w-inline-block"><img src="../images/Instagram.svg" loading="lazy" alt="Instagram logo" class="image-13"></a>
          <a href="https://www.linkedin.com/in/juan-diego-lugo-929a34205/" class="social-link w-inline-block"><img src="../images/LinkedIn.svg" loading="lazy" alt="LinkedIn logo" class="image-14"></a>
        </div><img src="https://uploads-ssl.webflow.com/602ca53e736379cc95d5f180/602ca53e58ea7fb6bb114f5c_Logo.svg" loading="lazy" width="187" alt="" class="image">
        <div class="text-block-3">@Juan Diego 2021<br>‍</div>
      </div>
    </div>
  </div>
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=602f42d4d0eb6ddf9136273c" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="../js/webflow.js" type="text/javascript"></script>
  <!-- [if lte IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/placeholders/3.0.2/placeholders.min.js"></script><![endif] -->
</body>
</html>