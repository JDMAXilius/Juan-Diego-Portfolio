<!DOCTYPE html><!--  This site was created in Webflow. http://www.webflow.com  -->
<!--  Last Published: Sun Oct 03 2021 18:32:20 GMT+0000 (Coordinated Universal Time)  -->
<html data-wf-page="61591d25f9cd71c67f9bf09c" data-wf-site="602f42d4d0eb6ddf9136273c">
<head>
  <meta charset="utf-8">
  <title>Raster Surface Triangle</title>
  <meta content="Raster Surface Triangle" property="og:title">
  <meta content="Raster Surface Triangle" property="twitter:title">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="Webflow" name="generator">
  <link href="../css/normalize.css" rel="stylesheet" type="text/css">
  <link href="../css/webflow.css" rel="stylesheet" type="text/css">
  <link href="../css/juan-diegos-portfolio.webflow.css" rel="stylesheet" type="text/css">
  <!-- [if lt IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" type="text/javascript"></script><![endif] -->
  <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <link href="../images/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <link href="../images/webclip.png" rel="apple-touch-icon">
</head>
<body class="body">
  <div data-w-id="ff3ac0b1-c979-2917-beb2-e00e39f97f07" data-animation="over-right" data-collapse="medium" data-duration="400" data-easing="ease" data-easing2="ease" role="banner" class="navbar-3 w-nav">
    <div class="container-8 w-container">
      <a href="../index.html" class="nav-logo-link"><img src="../images/Logo-Name-Portfolio.png" alt="IMAGE" class="nav-logo"></a>
      <nav role="navigation" class="nav-menu-3 w-nav-menu">
        <a href="../index.html" class="nav-link home works w-nav-link">HOME</a>
        <a href="#" class="nav-link home works w-nav-link">SUMMARY</a>
        <a href="#" class="nav-link home works w-nav-link">FEATURES</a>
        <a href="#" class="nav-link home works w-nav-link">DESIGN</a>
      </nav>
      <div class="menu-button-2 w-nav-button">
        <div class="w-icon-nav-menu"></div>
      </div>
    </div>
  </div>
  <div class="section background-black curses wf-section">
    <div class="centered-container-7 this curses w-container">
      <h1 class="heading-curses this curses">Raster Surface Triangle</h1>
      <p class="paragraph-5 curses">This project is about the process of creating a triangle primitive in 2D space, hence forth known as NDC (Normalized Device Coordinates).  The range of NDC by default goes from -1 and +1 on the X axis,  -1 and +1 on the Y axis, -1 and +1 on the Z axis<br></p>
    </div>
    <div class="div-block-32 dl curses">
      <div class="text-block-11 curses">Feel Free to Download the Source Code.</div>
      <a href="https://github.com/JDMAXilius/Raster-Surface-Texture-Array.git" target="_blank" class="button-6 ds w-button">Source Code</a>
    </div>
    <div class="container-7 curses w-container">
      <h2 class="heading-26-curse-2"><strong>Project Topics</strong></h2>
      <div class="div-block-35 curses">
        <p id="w-node-_4b365bf6-226d-4660-c8d0-3170586a2276-7f9bf09c" class="paragrahps-2 blog this colum"><strong>Explanations<br></strong>The Cross Product  <br>Optimization: Back-face Culling  <br>Back-face Culling  <br>What is a “Normal”?  <br>Face Normals  <br>What is Light?  <br>Problems with simulating actual photons  <br>Lambertian Reflectance  <br>Specular Reflectance  <br>Basic Types of Light Sources  <br>Directional Light Formula  <br>Point Light Formula  <br>Spot Light Formula  <br>Ambient Term <br>Light Attenuation [Linear]  <br>Specular Component  <br>Adding Vertex Lighting (Gouraud Shading)  <br>Adding Per-Pixel Lighting (Phong Shading) <br>Physically Based Rendering <strong><br></strong></p>
        <p class="paragrahps-2 blog curses">‍<strong class="bold-text">Code</strong><br>Main<br>Defines<br>3D Math<br>Shaders<br>Raster Functions<strong><br></strong></p>
      </div>
    </div>
    <section id="Features" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Objectives</strong></h2>
    </section>
    <div class="div-block-34 curses"><img src="../images/Raster-Surface-Triangle.PNG" loading="lazy" width="391" sizes="(max-width: 1439px) 30vw, (max-width: 1919px) 25vw, 391px" srcset="../images/Raster-Surface-Triangle-p-500.png 500w, ../images/Raster-Surface-Triangle.PNG 502w" alt="image" class="image-19 curses"></div>
    <div class="container-7 curses w-container">
      <div class="rich-text-block-5 curses heading-curses w-richtext">
        <p>Code Clean </p>
        <ul role="list">
          <li>Refactor your code so that it isn’t all in your main.cpp </li>
          <li>You can make header files, classes, structures.  Use critical thinking on how to make your code fit together! </li>
        </ul>
        <p>Rotating triangle (lines only) </p>
        <ul role="list">
          <li>This step involves using the <strong>VERTEX</strong> shader alongside your own vertex structure. </li>
        </ul>
        <p>Rotating triangle (filled to a solid color with white border lines) </p>
        <ul role="list">
          <li>This step will be introducing the barycentric formula to fill the triangle. </li>
        </ul>
        <p>Rotating triangle (interpolated colors with white border lines) </p>
        <ul role="list">
          <li>This step will involve the barycentric formula and the <strong>PIXEL</strong> shader to determine which color to use. </li>
        </ul>
      </div>
    </div>
    <section id="Code" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Programming Code</strong></h2>
    </section>
    <div data-hover="false" data-delay="0" class="dropdown-2 curses w-dropdown">
      <div data-w-id="4b365bf6-226d-4660-c8d0-3170586a22da" class="dropdown-toggle-2 w-dropdown-toggle">
        <div data-w-id="4b365bf6-226d-4660-c8d0-3170586a22db" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Main</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog"><strong>‍</strong>int main()<br>{<br> RS_Initialize(Raster_W, Raster_H); //time<br> XTime time;<br> // Set up rotation matrices<br> mat3x3 matRotZ, matRotX;<br> // Initialize constant drawing data. (BE SURE IT IS CONSTANT!!!)<br> const VERTEX UnEditableOriginalLine[3] =<br> {<br> {-0.5, +0.5, 1, 1, colorR }, { +0.5, -0.5, 1, 1, colorG }, { -0.5, -0.5, 1, 1, colorB }  // Defines a fixed diagonal line crossing the origin.    <br> };<br>‍<br> const triangleV verticesOriginals =<br> {<br> {-0.5, +0.5, 1, 1, colorR , +0.5, -0.5, 1, 1, colorG , -0.5, -0.5, 1, 1, colorB }<br> }; <br><br>do { Clear(0x000000);<br> //RUNS TIME<br> time.Signal(); // Select appropriate Shaders you want to Use. REMEMBER! You can make as many as you want!<br> // Only ever having one type of shader defeats the purpose! (This exists for flexibility!)<br> VertexShader = VS_World; // I choose a shader that will multiply by a single matrix that I control.  <br> PixelShader = PS_White; // Regardless of the original color I want all pixels to be shown white. <br> <br> // Set any custom variables used by the shader functions so you can control shader behaviors directly! <br> SV_WorldMatrix = matrixRotationZ(time.TotalTimeExact() * fTheta);<br> <br> //Fill Triangule<br> fillTriangle(UnEditableOriginalLine[0], UnEditableOriginalLine[1], UnEditableOriginalLine[2], colorG);<br> <br> //Draw triangule lines<br> // With appropriate shaders chosen we draw the fixed line. (A copy will be modifed by shaders)<br> DrawLine(UnEditableOriginalLine[0], UnEditableOriginalLine[1]);<br> DrawLine(UnEditableOriginalLine[1], UnEditableOriginalLine[2]);<br> DrawLine(UnEditableOriginalLine[2], UnEditableOriginalLine[0]); } while (RS_Update(raster, R_PIXELS));<br> RS_Shutdown();<br> return 0;}<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 curses w-dropdown">
      <div data-w-id="4b365bf6-226d-4660-c8d0-3170586a232d" class="dropdown-toggle-2 w-dropdown-toggle">
        <div data-w-id="4b365bf6-226d-4660-c8d0-3170586a232e" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Defines</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog"><strong>‍</strong>#define Raster_W 500 <br>#define Raster_H 500 <br>#define R_PIXELS ((Raster_W)*(Raster_H))<br>unsigned int raster[R_PIXELS] = { 0, };<br>unsigned colorR = 0xFF0000;<br>unsigned colorG = 0x00FF00;<br>unsigned colorB = 0x0000FF;float fTheta = -60;<br><br>struct VERTEX<br>{<br> float x,y,z,w;<br> unsigned int color;<br>};<br><br>struct triangleV<br>{<br> VERTEX p[3];<br>};<br>‍<br>struct meshV<br>{<br> vector&lt;triangleV&gt; trisV;<br>};<br>‍<br>struct mat3x3<br>{<br> float m[3][3] = { 0 };<br>};<br>‍<br>//<br>struct vec3d<br>{<br> float x, y, z;<br>};<br><br>struct triangle<br>{<br> vec3d p[3];<br>};<br><br>struct mesh<br>{<br> vector&lt;triangle&gt; tris;<br>};<br><br>struct mat4x4<br>{<br> float m[4][4] = { 0 };<br>};<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 curses w-dropdown">
      <div data-w-id="4b365bf6-226d-4660-c8d0-3170586a2394" class="dropdown-toggle-2 w-dropdown-toggle">
        <div data-w-id="4b365bf6-226d-4660-c8d0-3170586a2395" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">3D Math</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog"><strong>‍</strong>// Ax + By + C = 0<br>//(Y1 - Y2)x + (X2 - X1)y + X1Y2 - Y1X2 = 0<br>float ImplicitLineEq2(VERTEX a, VERTEX b, VERTEX p)<br>{<br> return (a.y - b.y) * p.x + (b.x - a.x) * p.y + a.x * b.y - a.y * b.x;<br>}//lerp(a, b, x) = a + (b -a ) * x<br>float lerpEq(int a, int b, int r)<br>{<br> return(b - a) * r + a;<br>}<br><br>//lerp(a, b, c, x) = ((a * x) + (b * x) + (c * x)); or P=(uA)+(vB)+(wC)<br>float barycentriclerpEq(int a, int b, int c, VERTEX r)<br>{<br> return((a * r.x) + (b * r.y) + (c * r.z));<br> <br>}<br><br>void NDCToScreen(float ndc_x, float ndc_y)<br>{<br> //NDC -&gt; Screen<br> int screen_x, screen_y;<br> screen_x = (ndc_x + 1) * ((Raster_W - 1) / 2);<br> screen_y = (1 - ndc_y) * ((Raster_H - 1) / 2);<br>}<br><br>VERTEX NDC2(VERTEX ndc)<br>{<br> //NDC -&gt; Screen<br> VERTEX screen;<br> <br> screen.x = ((ndc.x + 1) * (Raster_W / 2));<br> screen.y = ((1 - ndc.y) * (Raster_H / 2));<br> //result<br> return screen;<br>}<br>‍<br>void drawpixel(int x, int y, int W, unsigned int color)<br>{<br> raster[W * y + x] = color;<br>}<br><br>//Barycentric Interpolation<br>VERTEX BarycentricCoordinates(VERTEX a, VERTEX b, VERTEX c, VERTEX p)<br>{<br> VERTEX Pβγα; float β = ImplicitLineEq2(b, a, c);<br> float γ = ImplicitLineEq2(c, b, a);<br> float α = ImplicitLineEq2(a, c, b);<br> float B = ImplicitLineEq2(p, a, c);<br> float Y = ImplicitLineEq2(p, b, a);<br> float A = ImplicitLineEq2(p, c, b); Pβγα = { (B / β), (Y / γ), (A / α) }; return Pβγα;<br>}<br><br>triangleV triangleVMultMatrix(triangleV v, mat3x3 m)<br>{<br> triangleV t;<br> t.p[0].x = (v.p[0].x * m.m[0][0]) + (v.p[0].y * m.m[1][0]) + (v.p[0].z * m.m[2][0]);<br> t.p[1].x = (v.p[1].x * m.m[0][1]) + (v.p[1].y * m.m[1][1]) + (v.p[1].z * m.m[2][1]);<br> t.p[2].x = (v.p[2].x * m.m[0][2]) + (v.p[2].y * m.m[1][2]) + (v.p[2].z * m.m[2][2]);<br> float w = v.p[0].x * m.m[0][2] + v.p[0].y * m.m[1][2] + v.p[0].y * m.m[2][2]; if (w != 0.0f)<br> {<br> t.p[0].x /= w; t.p[0].y /= w; t.p[0].z /= w;<br> }<br> return t;<br>}<br><br>VERTEX vertexMultMatrix(VERTEX v, mat3x3 m)<br>{<br> VERTEX vex;<br> vex.x = (v.x * m.m[0][0]) + (v.y * m.m[1][0]) + (v.z * m.m[2][0]);<br> vex.y = (v.x * m.m[0][1]) + (v.y * m.m[1][1]) + (v.z * m.m[2][1]);<br> vex.z = (v.x * m.m[0][2]) + (v.y * m.m[1][2]) + (v.z * m.m[2][2]);<br> float w = v.x * m.m[0][2] + v.y * m.m[1][2] + v.y * m.m[2][2];<br> return vex;<br>}<br><br>mat3x3 matrixMultMatrix(mat3x3 m, mat3x3 l)<br>{<br> mat3x3 results;<br> float product = 0;<br> int i;<br> int j; for (i = 1; i &lt;= 3; i++) {<br> for (j = 1; j &lt;= 3; j++) {<br> product += m.m[i][j] * l.m[j][i];<br> cout &lt;&lt; product &lt;&lt; endl;<br> }<br> results.m[i][j] = product;<br> product = 0;<br> }<br> return results;<br>}<br>‍<br>void matrixIdentity()<br>{}<br>‍<br>mat3x3 matrixRotationZ( float fTheta)<br>{<br> mat3x3 matRotX = { 0 };<br> fTheta = fTheta / 180.0f * 3.14; // Rotation Z<br> matRotX.m[0][0] = cosf(fTheta * 0.5f);<br> matRotX.m[0][1] = sinf(fTheta * 0.5f);<br> matRotX.m[1][0] = -sinf(fTheta * 0.5f);<br> matRotX.m[1][1] = cosf(fTheta * 0.5f);<br> matRotX.m[2][2] = 1; return matRotX;<br>}<br>‍<br>mat3x3 matrixRotationX( float fTheta)<br>{<br> mat3x3 matRotX = { 0 };<br> fTheta = fTheta / 180.0f * 3.14;<br> <br> // Rotation X<br> matRotX.m[0][0] = 1;<br> matRotX.m[1][1] = cosf(fTheta * 0.5f);<br> matRotX.m[1][2] = sinf(fTheta * 0.5f);<br> matRotX.m[2][1] = -sinf(fTheta * 0.5f);<br> matRotX.m[2][2] = cosf(fTheta * 0.5f);<br> return matRotX;<br>}<br>‍<br>void matrixTranslation()<br>{}<br><br>void MultiplyMatrixVector(triangleV v, triangleV o, mat3x3 m)<br>{<br> <br> o.p[0].x = (v.p[0].x * m.m[0][0]) + (v.p[0].y * m.m[1][0]) + (v.p[0].z * m.m[3][0]);<br> o.p[1].x = (v.p[1].x * m.m[0][1]) + (v.p[1].y * m.m[1][1]) + (v.p[1].z * m.m[3][1]);<br> o.p[2].x = (v.p[2].x * m.m[0][2]) + (v.p[2].y * m.m[1][2]) + (v.p[2].z * m.m[3][2]);<br> float w = v.p[0].x * m.m[0][3] + v.p[0].y * m.m[1][3] + v.p[0].y * m.m[2][3] + m.m[3][3]; if (w != 0.0f)<br> {<br> o.p[0].x /= w; o.p[0].y /= w; o.p[0].z /= w;<br> }<br>}<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="4b365bf6-226d-4660-c8d0-3170586a24a2" class="dropdown-toggle-2 w-dropdown-toggle">
        <div data-w-id="4b365bf6-226d-4660-c8d0-3170586a24a3" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Shaders</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog"><strong>‍</strong>//// The active vertex shader. Modifies an incoming vertex. Pre-Rasterization. <br>void (*VertexShader)(VERTEX&amp;) = 0;<br>//// The active pixel shader. Modifies an outgoing pixel. Post-Rasterization.<br>void (*PixelShader)(unsigned int&amp;) = 0;<br>//<br>//// All Shader Variables (Always Pre-fixed by “SV_”)<br>mat3x3 SV_WorldMatrix;// Various custom vertex and pixel shaders, (Pre-fixed by “VS_” &amp; “PS_”)<br>‍<br>// Can be swapped using above function pointers as needed for flexibility. // Applys the current world matrix to all<br>void VS_World(VERTEX&amp; multiplyMe)<br>{<br>    multiplyMe = vertexMultMatrix(multiplyMe, SV_WorldMatrix);}<br>‍<br>// Basic pixel shader returns the color white<br>void PS_White(unsigned int&amp; makeWhite)<br>{<br>    makeWhite = 0xFFFFFFFF;<br>}<br></p>
        </div>
      </nav>
    </div>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="4b365bf6-226d-4660-c8d0-3170586a24d0" class="dropdown-toggle-2 w-dropdown-toggle">
        <div data-w-id="4b365bf6-226d-4660-c8d0-3170586a24d1" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Raster Funtions</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="paragrahps-2 blog"><strong>‍</strong>void Clear(unsigned int color)<br>{<br> for (size_t i = 0; i &lt; R_PIXELS; i++)<br> {<br> raster[i] = color;<br> }<br>}<br><br>void PlotPixel(int x, int y, unsigned color)<br>{<br> assert(x &gt;= 0 &amp;&amp; x &lt;= Raster_W);<br> assert(y &gt;= 0 &amp;&amp; y &lt;= Raster_H);<br> raster[Raster_W * y + x] = color;<br>}<br><br>void DrawLinepixel(int x1, int y1, int x2, int y2, unsigned color)<br>{ unsigned colorS = color; int deltaXB = std::abs(y1 - x1);<br> int deltaYB = std::abs(y2 - x2);<br> int totalPB = (deltaXB &gt; deltaYB) ? deltaXB : deltaYB; for (int i = 0; i &lt; totalPB; i++)<br> {<br> float rB = static_cast&lt;float&gt;(i) / static_cast&lt;float&gt;(totalPB);<br> // (B-A) * R + A<br> /*int xB = (y1 - x1) * rB + x1;<br> int yB = (y2 - x2) * rB + x2;*/<br> int xB = (x1 + rB *(y1 - x1) + 0.5f);<br> int yB = (x2 + rB *(y2 - x2) + 0.5f); PlotPixel(xB, yB, colorS);<br> } ////End points Bresenham<br> PlotPixel(x1, x2, 0xFFFF00);<br> PlotPixel(y1, y2, 0xFFFF00);<br>}<br><br>unsigned ColorLerp(unsigned a, unsigned b, int r)<br>{<br> //a values<br> int a1 = (a &amp; 0xFF000000) &gt;&gt; 24;<br> int a2 = (a &amp; 0x00FF0000) &gt;&gt; 16;<br> int a3 = (a &amp; 0x0000FF00) &gt;&gt; 8;<br> int a4 = (a &amp; 0x000000FF); //b values<br> int b1 = (b &amp; 0xFF000000) &gt;&gt; 24;<br> int b2 = (b &amp; 0x00FF0000) &gt;&gt; 16;<br> int b3 = (b &amp; 0x0000FF00) &gt;&gt; 8;<br> int b4 = (b &amp; 0x000000FF); //math of lerp<br> unsigned int f1 = (b1 - a1) * r + a1;<br> unsigned int f2 = (b2 - a2) * r + a2;<br> unsigned int f3 = (b3 - a3) * r + a3;<br> unsigned int f4 = (b4 - a4) * r + a4; return (f1 &lt;&lt; 24) | (f2 &lt;&lt; 16) | (f3 &lt;&lt; 8) | f4;<br>}<br><br>unsigned BarycentricCoordinatesColorLerp(unsigned a, unsigned b, unsigned c, VERTEX r)<br>{<br> //a values<br> int a1 = (a &amp; 0xFF000000) &gt;&gt; 24;<br> int a2 = (a &amp; 0x00FF0000) &gt;&gt; 16;<br> int a3 = (a &amp; 0x0000FF00) &gt;&gt; 8;<br> int a4 = (a &amp; 0x000000FF); //b values<br> int b1 = (b &amp; 0xFF000000) &gt;&gt; 24;<br> int b2 = (b &amp; 0x00FF0000) &gt;&gt; 16;<br> int b3 = (b &amp; 0x0000FF00) &gt;&gt; 8;<br> int b4 = (b &amp; 0x000000FF); //c values<br> int c1 = (c &amp; 0xFF000000) &gt;&gt; 24;<br> int c2 = (c &amp; 0x00FF0000) &gt;&gt; 16;<br> int c3 = (c &amp; 0x0000FF00) &gt;&gt; 8;<br> int c4 = (c &amp; 0x000000FF); //math of lerp<br> unsigned int f1 = barycentriclerpEq(a1, b1, c1, r);<br> unsigned int f2 = barycentriclerpEq(a2, b2, c2, r);<br> unsigned int f3 = barycentriclerpEq(a3, b3, c3, r);<br> unsigned int f4 = barycentriclerpEq(a4, b4, c4, r); return (f1 &lt;&lt; 24) | (f2 &lt;&lt; 16) | (f3 &lt;&lt; 8) | f4;<br>}<br><br>void DrawLinepixelvertex(VERTEX a, VERTEX b, unsigned int color)<br>{ unsigned colorS = color; int deltaXB = std::abs(b.x - a.x);<br> int deltaYB = std::abs(b.y - a.y);<br> int totalPB = (deltaXB &gt; deltaYB) ? deltaXB : deltaYB; for (int i = 0; i &lt; totalPB; i++)<br> {<br> float rB = i / static_cast&lt;float&gt;(totalPB);<br> // (B-A) * R + A<br> /*int xB = (y1 - x1) * rB + x1;<br> int yB = (y2 - x2) * rB + x2;*/<br> int xB = (a.x + rB * (b.x - a.x) + 0.5f);<br> int yB = (a.y + rB * (b.y - a.y) + 0.5f); PlotPixel(xB, yB, colorS);<br> } //End points Bresenham<br> PlotPixel(a.x, a.y, 0xFFFF00);<br> PlotPixel(b.x, b.y, 0xFFFF00);<br>}<br><br>void DrawTriangle3(VERTEX a, VERTEX b, VERTEX c)<br>{<br> //points<br> VERTEX A = { a };<br> VERTEX B = { b };<br> VERTEX C = { c }; //NDC -&gt; Screen<br> a = NDC2(A);<br> b = NDC2(B);<br> c = NDC2(C); //Drawing pixels &amp; lines<br> DrawLinepixelvertex(a, b, 0xFFFFFFFF);<br> DrawLinepixelvertex(b, c, 0xFFFFFFFF);<br> DrawLinepixelvertex(c, a, 0xFFFFFFFF);<br>}<br>‍<br>void DrawTriangle2(VERTEX a, VERTEX b, VERTEX c)<br>{<br> //points<br> VERTEX A = { a };<br> VERTEX B = { b };<br> VERTEX C = { c }; //NDC -&gt; Screen<br> a = NDC2(A);<br> b = NDC2(B);<br> c = NDC2(C); //Drawing pixels &amp; lines<br> DrawLinepixel(a.x, a.y, b.x, b.y, 0xFFFFFFFF);<br> DrawLinepixel(b.x, b.y, c.x, c.y, 0xFFFFFFFF);<br> DrawLinepixel(c.x, c.y, a.x, a.y, 0xFFFFFFFF);<br>}<br><br>void fillTriangle(VERTEX a, VERTEX b, VERTEX c, unsigned color)<br>{ //DrawTriangle3(a, b, c);<br> VERTEX A = { a };<br> VERTEX B = { b };<br> VERTEX C = { c }; // Use vertex shader to modify incoming copies only.<br> if (VertexShader)<br> {<br> VertexShader(A);<br> VertexShader(B);<br> VertexShader(C);<br> } //NDC -&gt; Screen<br> a = NDC2(A);<br> b = NDC2(B);<br> c = NDC2(C); //loop across screen, examine x &amp; y<br> for (int y = 0; y &lt; Raster_H; y++)<br> {<br> for (int x = 0; x &lt; Raster_W; x++)<br> {<br> //x&amp;y pixel loc<br> VERTEX P<br> {<br> static_cast&lt;float&gt;(x),<br> static_cast&lt;float&gt;(y),<br> };<br> //the three pionts<br> //the three joining lines<br> float result1 = ImplicitLineEq2(a, b, P);<br> float result2 = ImplicitLineEq2(b, c, P);<br> float result3 = ImplicitLineEq2(a, c, P); <br>                        <br>                        color = BarycentricCoordinatesColorLerp(colorR, colorG, colorB, <br> BarycentricCoordinates(a, b, c, P)); <br>                        if (result1 &gt; 0 &amp;&amp; result2 &gt; 0 &amp;&amp; result3 &lt; 0)<br> raster[y * Raster_W + x] = color;<br> }<br> }<br>}<br><br>//// Draws a line using one of the line equations.<br>void DrawLine(const VERTEX&amp; start, const VERTEX&amp; end)<br>{<br> // Copy input data and send through shaders<br> VERTEX copy_start = start;<br> VERTEX copy_end = end;<br> // Use vertex shader to modify incoming copies only.<br> if (VertexShader)<br> {<br> VertexShader(copy_start);<br> VertexShader(copy_end);<br> }<br> // original plotting variables adapted to use new cartesian data<br> VERTEX screen_start = NDC2(copy_start);<br> VERTEX screen_end = NDC2(copy_end);<br> // Standard line drawing code follows using integer coordinates...<br> DrawLinepixelvertex(screen_start, screen_end, 0xFFFFFFFF);<br>}<br></p>
        </div>
      </nav>
    </div>
    <section id="Features" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Guidance</strong></h2>
    </section>
    <div class="container-7 curses w-container">
      <div class="rich-text-block-5 blog curses heading-curses w-richtext">
        <ol start="1" role="list">
          <li>let’s go ahead and create a <strong>VERTEX</strong> structure.  The <strong>VERTEX</strong> structure will contain 2 data members.  The first will be an array of 4 floats. The second will be an unsigned integer for the color. </li>
        </ol>
        <ol start="2" role="list">
          <li>Create an array of 3 vertex structure objects, and define their information.  Make sure to not exceed the bounds of NDC.  For the color, make each verex a different value, preferable RED GREEN and BLUE. </li>
        </ol>
        <ol start="3" role="list">
          <li>Let’s keep in mind that we will need to do some coordinate conversions from NDC to SCREEN values to properly plot our pixels.  This is a good time to create a function for doing so.  Remember, we should keep our code neat, so we will need to place this function in one of the new header files we created. </li>
        </ol>
        <ol start="4" role="list">
          <li>Draw three lines connecting each VERTEX to make a triangle.  Additionally, we want to rotate each VERTEX by a rotation matrix.  This rotation will be handled by a <strong>vertex shader</strong> you create.  Continue to rotate the triangle by time.  (It should spin continuously). </li>
        </ol>
        <ol start="5" role="list">
          <li>One we have the lines drawing properly, it’s time to fill the triangle.  At first you can fill the triangle to a solid color but we need to interpolate the color values between all three vertices.  In order to fill the triangle, we will need to do the barycentric calculations in order to see if our pixel is currently inside the triangle. </li>
        </ol>
      </div>
    </div>
    <section id="Features" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Programming Explanation</strong></h2>
    </section>
    <div class="container-7 curses w-container">
      <div class="rich-text-block-5 curses heading-curses w-richtext">
        <p><strong>Working in Screen/Pixel Space</strong> </p>
        <p>Pros </p>
        <ul role="list">
          <li>1 unit = 1 pixel, distance is easy to understand. </li>
          <li>Working with 2D sprites is straightforward. </li>
          <li>You can operate completely in whole numbers if you want to. </li>
          <li>A direct representation of what you see. </li>
        </ul>
        <p>Cons </p>
        <ul role="list">
          <li>The raster has no Z it is completely 2D. </li>
          <li>Y is going “down” instead of “up” unlike most mathematical Cartesian representations. </li>
          <li>Translating or rotating vector shapes using integers alone could cause significant errors and information loss. </li>
          <li>Everything is resolution dependent! </li>
          <li>Insufficient information available to represent a fully 3D environment. </li>
        </ul>
        <p><strong>Working in 3D Space</strong> </p>
        <p>Pros </p>
        <p> </p>
        <ul role="list">
          <li>A virtual 3D representation of all the things you “could” see! </li>
          <li>Full 3D Rotation, Translation and Scaling is possible without truncation errors! </li>
          <li>1 unit = Whatever you want as long as you are consistent! (feet, meters, yards…) </li>
          <li>Independent of 2D raster resolution! </li>
        </ul>
        <p>Cons </p>
        <ul role="list">
          <li>Not as direct when working in 2D alone. </li>
          <li>Requires Rasterization: The conversion of vector coordinates to raster coordinates so shapes can actually be drawn. </li>
          <li>More complex to understand. </li>
        </ul>
        <p> </p>
        <p><strong>The Screen in 3D Normalized Device Coordinates</strong> </p>
        <p>A.K.A The Canonical View Volume. </p>
        <p>This coordinate system is always the same regardless of what you set your screen pixel width &amp; height. </p>
        <p>Notice how the origin is now in the center and that we have a Z axis available. </p>
        <p>As we start to work in 3D this system will be much easier to deal with. </p>
        <p><strong>Using 3D to Our Advantage</strong> </p>
        <ul role="list">
          <li>We will learn many ways to take advantage of this new system. </li>
          <li>To start we will need a better way to represent a location in this space. </li>
        </ul>
        <ul role="list">
          <li>A “Vertex” representing where two edges meet will be very convenient. </li>
          <li><strong><em>Coding Tip:</em></strong> struct VERTEX { float xyzw[4]; uint color; } </li>
        </ul>
        <ul role="list">
          <li>We won’t really capitalize on the Z or W today, but they will be useful later… </li>
        </ul>
        <ul role="list">
          <li>Once our shapes are stored in this 3D Space, it will be easier for us to rotate them around the screen center. (now the origin) </li>
        </ul>
        <p><strong>Adding Flexibility: Shaders</strong> </p>
        <ul role="list">
          <li>Currently if you draw a line… you draw EXACTLY that line… </li>
          <li>Wouldn&#x27;t it be useful to draw the same line in a different spot without having to remake it? What if we wanted to do this every frame? </li>
        </ul>
        <ul role="list">
          <li>What if multiple lines needed to move or rotate together as a group? </li>
        </ul>
        <ul role="list">
          <li>What if we wanted to temporarily draw the line a different color? </li>
        </ul>
        <ul role="list">
          <li>Perhaps our vector “spaceship” takes some damage and should flash red! </li>
        </ul>
        <ul role="list">
          <li>Shaders are customizable and “interchangeable” functions that intercept &amp; modify data right before we draw it to the screen. </li>
        </ul>
        <p><strong>Triangle Rasterization</strong> </p>
        <ul role="list">
          <li>The last type of primitive we will learn to draw on the 2D raster grid is going to be the triangle. </li>
        </ul>
        <ul role="list">
          <li>However, we will define them in our new 3D coordinate system. </li>
        </ul>
        <ul role="list">
          <li>Triangles can be connected together to form every other type of polygon, which makes them very versatile. </li>
        </ul>
        <ul role="list">
          <li>Nearly everything you see in a modern game or simulation is comprised of triangles. </li>
        </ul>
        <ul role="list">
          <li>Your current knowledge would allow you to draw the “outline” of a triangle, but not much else. </li>
          <li>In order to “fill” a triangle with pixels, we will need to dig deeper into the math behind triangles, and how the space within a triangle is defined. </li>
        </ul>
        <p> </p>
        <p><strong>Barycentric Coordinates</strong> </p>
        <p>Defines a Non-Orthogonal coordinate system describing the space of a triangle. </p>
        <p>Any position on this plane can be described with the following equation: </p>
        <p>P = β( B – A ) + γ( C – A ) + A  </p>
        <p>Terms Reordered: </p>
        <p>P = ( 1 - β - γ )A + β( B ) + γ( C ) </p>
        <p>α = ( 1 - β - γ ) </p>
        <p>P ( α, β, γ ) = αA + βB + γC </p>
        <p>Finding the Barycentric Coordinates of a point relative to a triangle </p>
        <p>β = ImplicitLineEquation ( B, line AC ) </p>
        <p>γ = ImplicitLineEquation ( C, line BA )  </p>
        <p>α = ImplicitLineEquation ( A, line CB ) </p>
        <p>b = ImplicitLineEquation ( <strong>P</strong>, line AC ) </p>
        <p>y = ImplicitLineEquation ( <strong>P</strong>, line BA ) </p>
        <p>a = ImplicitLineEquation ( <strong>P</strong>, line CB ) </p>
        <p><strong>P</strong>βγα = ( b / β , y / γ, a / α )    </p>
        <p>Could we use the Barycentric coordinates to detect if we are inside or outside the triangle? If so… how? </p>
        <p> </p>
        <p><strong>Brute Triangle</strong> </p>
        <p>FOR ALL PIXELS </p>
        <p>bya = FindBarycentric ( CurrX, CurrY ) </p>
        <p>IF b &gt;=0 &amp;&amp; b &lt;= 1 &amp;&amp;  </p>
        <p>y &gt;=0 &amp;&amp; y &lt;= 1 &amp;&amp; </p>
        <p>a &gt;=0 &amp;&amp; a &lt;= 1 </p>
        <p>THEN </p>
        <p>PlotPixel ( CurrX, CurrY ) </p>
        <p><strong>Better Brute Triangle</strong> </p>
        <p>StartX = MIN ( X1, X2, X3 ) </p>
        <p>StartY = MIN ( Y1, Y2, Y3 ) </p>
        <p>EndX = MAX ( X1, X2, X3 ) </p>
        <p>EndY = MAX ( Y1, Y2, Y3 ) </p>
        <p>FOR StartY to EndY </p>
        <p>FOR StartX to EndX </p>
        <p>bya = FindBarycentric ( CurrX, CurrY ) </p>
        <p>IF b &gt;=0 &amp;&amp; b &lt;= 1 &amp;&amp;  </p>
        <p>y &gt;=0 &amp;&amp; y &lt;= 1 &amp;&amp; </p>
        <p>a &gt;=0 &amp;&amp; a &lt;= 1 </p>
        <p>THEN </p>
        <p>PlotPixel ( CurrX, CurrY ) </p>
        <p><strong>Lari’s Parametric Triangle</strong> </p>
        <ul role="list">
          <li>Step 1: Sort the VERTS in Y Ascending. </li>
          <li>Step 2: Determine the “Direction of Fill” by comparing the Middle vertex to the opposite line. (Use the Implicit Line Equation) </li>
          <li>Step 3: Use the Parametric Line Equation to find the closest staring pixel for each row on the tallest line. (Top to Bottom)  </li>
          <li>Step 4: Determine if the Pixel’s center is within the Barycentric space of the triangle. If it is you should Draw that pixel. </li>
          <li>Step 5: Continue drawing pixels on that row until you leave Barycentric space. (Ignore any pixels below the parametric line) </li>
        </ul>
        <p><strong>Barycentric Interpolation</strong> </p>
        <ul role="list">
          <li>Surprise! Barycentric coordinates are ALREADY ratios that add up to 1 </li>
          <li>Linear Interpolation: X = ( B – A ) * R + A </li>
          <li>Linear written another way: X = ( B * R ) + A * ( 1 – R )  </li>
          <li>1.0 = β + γ + α  So… </li>
          <li>Barycentric Interpolation: X = A * α + B * β + C * γ  </li>
          <li>Well that was easy! =) </li>
        </ul>
        <p>‍</p>
      </div>
    </div>
  </div>
  <div class="section-2 footer background-black wf-section">
    <div class="container-4 w-container">
      <div class="footer-holder">
        <div class="social-wrapper">
          <a href="https://juan_diego_lugo.artstation.com" target="_blank" class="social-link w-inline-block"><img src="../images/Artstation.png" loading="lazy" alt="" class="image-13"></a>
          <a href="https://github.com/JDMAXilius" target="_blank" class="social-link w-inline-block"><img src="../images/github.png" loading="lazy" alt="image" class="image-13"></a>
          <a href="https://www.youtube.com/channel/UCRjr5hvDeIpc_SfgTO690RA/featured" target="_blank" class="social-link w-inline-block"><img src="../images/youtube.png" loading="lazy" alt="" class="image-13"></a>
          <a href="#" class="social-link w-inline-block"><img src="../images/pngfind.com-discord-icon-png-283551.png" loading="lazy" sizes="40px" srcset="../images/pngfind.com-discord-icon-png-283551-p-500.png 500w, ../images/pngfind.com-discord-icon-png-283551-p-800.png 800w, ../images/pngfind.com-discord-icon-png-283551-p-1080.png 1080w, ../images/pngfind.com-discord-icon-png-283551.png 1468w" alt="" class="image-13"></a>
          <a href="https://www.facebook.com/juandiego.lugo1" target="_blank" class="social-link w-inline-block"><img src="../images/fb.png" loading="lazy" alt="" class="image-13 f"></a>
          <a href="#" class="social-link w-inline-block"><img src="../images/Instagram.svg" loading="lazy" alt="Instagram logo" class="image-13"></a>
          <a href="https://www.linkedin.com/in/juan-diego-lugo-929a34205/" class="social-link w-inline-block"><img src="../images/LinkedIn.svg" loading="lazy" alt="LinkedIn logo" class="image-14"></a>
        </div><img src="https://uploads-ssl.webflow.com/602ca53e736379cc95d5f180/602ca53e58ea7fb6bb114f5c_Logo.svg" loading="lazy" width="187" alt="" class="image">
        <div class="text-block-3">@Juan Diego 2021<br>‍</div>
      </div>
    </div>
  </div>
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=602f42d4d0eb6ddf9136273c" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="../js/webflow.js" type="text/javascript"></script>
  <!-- [if lte IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/placeholders/3.0.2/placeholders.min.js"></script><![endif] -->
</body>
</html>