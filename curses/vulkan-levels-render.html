<!DOCTYPE html><!--  This site was created in Webflow. https://www.webflow.com  -->
<!--  Last Published: Sat Sep 10 2022 03:50:01 GMT+0000 (Coordinated Universal Time)  -->
<html data-wf-page="62261964d2b8325d1cac1078" data-wf-site="602f42d4d0eb6ddf9136273c">
<head>
  <meta charset="utf-8">
  <title>Vulkan Levels Render</title>
  <meta content="Vulkan Levels Render" property="og:title">
  <meta content="Vulkan Levels Render" property="twitter:title">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="Webflow" name="generator">
  <link href="../css/normalize.css" rel="stylesheet" type="text/css">
  <link href="../css/webflow.css" rel="stylesheet" type="text/css">
  <link href="../css/juan-diegos-portfolio.webflow.css" rel="stylesheet" type="text/css">
  <!-- [if lt IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" type="text/javascript"></script><![endif] -->
  <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <link href="../images/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <link href="../images/webclip.png" rel="apple-touch-icon">
</head>
<body class="body">
  <div data-w-id="ff3ac0b1-c979-2917-beb2-e00e39f97f07" data-animation="over-right" data-collapse="medium" data-duration="400" data-easing="ease" data-easing2="ease" role="banner" class="navbar-3 w-nav">
    <div class="container-8 w-container">
      <a href="../index.html" class="nav-logo-link"><img src="../images/Logo-Name-Portfolio.png" alt="IMAGE" class="nav-logo"></a>
      <nav role="navigation" class="nav-menu-3 w-nav-menu">
        <a href="../index.html" class="nav-link home works w-nav-link">HOME</a>
        <a href="#" class="nav-link home works w-nav-link">SUMMARY</a>
        <a href="#" class="nav-link home works w-nav-link">FEATURES</a>
        <a href="#" class="nav-link home works code w-nav-link">CODE</a>
        <a href="#" class="nav-link home works w-nav-link">DESIGN</a>
      </nav>
      <div class="menu-button-2 w-nav-button">
        <div class="w-icon-nav-menu"></div>
      </div>
    </div>
  </div>
  <div class="section background-black curses wf-section">
    <div class="centered-container-7 this w-container">
      <h1 class="heading-curses this">Vulkan Levels Render</h1>
      <p class="paragraph-5 curses">The primary goal of the project is to apply all that I learned in the Vulkan API course to create software designed to draw the visual aspects of a gamelevel. <br></p>
      <div class="div-block-24">
        <div class="rich-text-block-4 w-richtext">
          <p> <strong>Software Used</strong>   </p>
          <p><strong>Languages Used </strong>  </p>
        </div>
        <div class="rich-text-block-3 w-richtext">
          <p>Visual Studio</p>
          <p>C++</p>
        </div>
      </div>
    </div>
    <div class="div-block-32 dl curses">
      <div class="text-block-11">Feel Free to Download the Source Code.</div>
      <a href="https://github.com/JDMAXilius/Vulkan_Levels_Render" target="_blank" class="button-6 ds w-button">Source Code</a>
    </div>
    <div class="container-7 w-container">
      <h2 class="heading-26-curse-2"><strong>Project Content<br></strong></h2>
      <p class="paragrahps-2 blog colum curses new"><strong>CORE FEATURES</strong><br>One or More Blender Game Levels to export from <br>Exporting OBJ Names &amp; Locations from your Levels <br>Run-time file I/O parsing of exported level information <br>Reading binary model data for all referenced models <br>Transfering model geometry, material and matrix data to GPU<br>One model imported from GameLevel.txt is drawing correctly<br>All models successfully drawn at proper location, orientation &amp; scale<br>All models have correct OBJ material colors showing<br>Working 3D Fly-through Camera<br>Directional light with ambient term and specular highlights<br><strong><br>KEY FEATURES<br></strong>Support for Hot-Swapping multiple levels without a restart<strong><br>‍</strong>Support for adding Point and/or Spotlight sources via Blender<br>Data Oriented Renderer with Unique Model Data and fully Instanced Drawcalls<br><br><strong>BONUS FEATURES</strong><br>Play Some Level Music <br>Add Some Sound Effects <br>Manage your project in a private GIT repo </p>
    </div>
    <section id="Features" class="flex-container line curses w-container"></section>
    <section id="Code" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Programming Code</strong></h2>
    </section>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="6d698fcd-3d73-34e6-a87b-2a5a413ece4b" class="dropdown-toggle-2 w-dropdown-toggle">
        <div data-w-id="6d698fcd-3d73-34e6-a87b-2a5a413ece4c" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Development Code</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="code-text">‍<strong>Code<br>‍</strong><br>// Simple Vertex Shader<br>const char* vertexShaderSource = R&quot;(<br>#pragma pack_matrix(row_major)<br>// TODO: 2i<br>// an ultra simple hlsl vertex shader<br>// TODO: Part 2b<br>struct ATTRIBUTES<br>{<br>    float3 Kd; // diffuse reflectivity<br>    float d; // dissolve (transparency) <br>    float3 Ks; // specular reflectivity<br>    float Ns; // specular exponent<br>    float3 Ka; // ambient reflectivity<br>    float sharpness; // local reflection map sharpness<br>    float3 Tf; // transmission filter<br>    float Ni; // optical density (index of refraction)<br>    float3 Ke; // emissive reflectivity<br>    uint illum; // illumination model<br>};<br>struct LIGHT {<br> uint type;<br> float radius;<br> float4 pos;<br> float4 color;<br> float4 dir;<br>};<br>struct SHADER_MODEL_DATA<br>{<br>    float4 sunDirection, sunColor, sunAmbient, camPos;<br>    matrix ViewMatrix, ProjectionMatrix;<br>    matrix matricies[1024];<br>    ATTRIBUTES materials[1024];<br> LIGHT light[16];<br>};<br>StructuredBuffer&lt;SHADER_MODEL_DATA&gt; SceneData;<br>// TODO: Part 4g<br>// TODO: Part 2i<br>// TODO: Part 3e<br>[[vk::push_constant]]<br>cbuffer Model_INDEX {<br> uint mesh_ID;<br> uint wm_ID;<br> uint Light_ID;<br>};<br>// TODO: Part 4a<br>// TODO: Part 1f<br>struct OBJ_VERT<br>{<br>    float3 pos : POSITION;<br>    float3 uvw : TEXCOORD0;<br>    float3 nrm : NORMAL;<br> //float4 RGBA : COLOR;<br>};<br>struct OutputStruct<br>{<br> float4 posH : SV_POSITION;<br> float3 nrmW : NORMAL;<br> float3 posW : WORLD;<br> float3 uvw : TEXTCOORD0;<br> //float4 RGBA : COLOR;<br> //float3 tangent : TEXTCOORD0;<br> //float3 bitangent : TEXTCOORD0;<br>};<br>// TODO: Part 4b<br>OutputStruct main(OBJ_VERT inputObj, uint instanceId : SV_INSTANCEID) : SV_POSITION<br>{<br> OutputStruct tempStruct;<br> float4 pos = float4(inputObj.pos, 1);<br> tempStruct.posH = mul(pos, SceneData[0].matricies[instanceId]);<br> tempStruct.nrmW = normalize(inputObj.nrm);<br> tempStruct.nrmW = mul(tempStruct.nrmW, SceneData[0].matricies[instanceId]); //vec3 normal = mat3( ModelViewMatrix ) * app_normal;<br> tempStruct.posW = tempStruct.posH;<br> tempStruct.posH = mul(tempStruct.posH, SceneData[0].ViewMatrix);<br> tempStruct.posH = mul(tempStruct.posH, SceneData[0].ProjectionMatrix); // gl_Position = ProjectionMatrix * ModelViewMatrix * app_position; <br> tempStruct.uvw = inputObj.uvw;<br> <br>    return tempStruct;<br>}<br>)&quot;;<br>// Simple Pixel Shader<br>const char* pixelShaderSource = R&quot;(<br>struct ATTRIBUTES<br>{<br>    float3 Kd; // diffuse reflectivity<br>    float d; // dissolve (transparency) <br>    float3 Ks; // specular reflectivity<br>    float Ns; // specular exponent<br>    float3 Ka; // ambient reflectivity<br>    float sharpness; // local reflection map sharpness<br>    float3 Tf; // transmission filter<br>    float Ni; // optical density (index of refraction)<br>    float3 Ke; // emissive reflectivity<br>    uint illum; // illumination model<br>};<br>struct LIGHT {<br> uint type;<br> float radius;<br> float4 pos;<br> float4 color;<br> float4 dir;<br>};<br>struct SHADER_MODEL_DATA<br>{<br>    float4 sunDirection, sunColor, sunAmbient, camPos;<br>    matrix ViewMatrix, ProjectionMatrix;<br>    matrix matricies[1024];<br>    ATTRIBUTES materials[1024];<br> LIGHT light[16];<br>};<br>StructuredBuffer&lt;SHADER_MODEL_DATA&gt; SceneData;<br>// TODO: Part 4g<br>// TODO: Part 2i<br>// TODO: Part 3e<br>[[vk::push_constant]]<br>cbuffer Model_INDEX<br>{<br>    uint mesh_ID;<br>    uint wm_ID;<br> uint Light_ID;<br>};<br>// TODO: Part 4a<br>// TODO: Part 1f<br>struct OBJ_VERT<br>{<br>    float3 pos : POSITION;<br>    float3 uvw : TEXCOORD0;<br>    float3 nrm : NORMAL;<br>};<br>struct InputStruct<br>{<br>    float4 posH : SV_POSITION;<br>    float3 nrmW : NORMAL;<br>    float3 posW : WORLD;<br>    float3 uvw : TEXTCOORD0;<br>};<br>float4 main(InputStruct inputObj) : SV_TARGET<br>{<br> inputObj.nrmW = normalize(inputObj.nrmW);<br> float4 Normal = normalize(float4(inputObj.nrmW, 0)); //float FANGLE = saturate(dot(Normal.xyz, -SceneData[0].sunDirection.xyz));// * SceneData[0].sunColor;<br> float FANGLE = saturate(dot(Normal.xyz, -SceneData[0].sunDirection.xyz)); float4 pointLight[2];<br> float3 lightP;<br> for (int i = 0; i &lt; 2; i++) <br> {<br> float3 lightDir = normalize(SceneData[0].light[i].pos - inputObj.posW);<br> float attenuation = 1.0f - saturate(length(SceneData[0].light[i].pos - inputObj.posW)/SceneData[0].light[i].radius);<br> float lightRatio = saturate(dot(lightDir, inputObj.nrmW)) * attenuation;<br> lightP = lightRatio * SceneData[0].light[i].color;// * SceneData[0].materials[mesh_ID].Kd;<br> pointLight[i] = float4(lightP, 0);<br> //Light_ID = i;<br> }; float4 DirectLight = SceneData[0].sunColor * FANGLE;<br> float4 Ambient = float4(0.25, 0.25, 0.35, 1.0);<br> //float4 Ambient = FANGLE + SceneData[0].sunAmbient; float4 IndirectLight = Ambient; // * (float4(SceneData[0].materials[mesh_ID].Kd, 1.0f));    float3 ViewDir = normalize(SceneData[0].camPos.xyz - inputObj.posW);<br>    float3 Halfvector = normalize((-SceneData[0].sunDirection.xyz) + ViewDir);<br> float Intensity = saturate(pow(dot(Normal, Halfvector), SceneData[0].materials[mesh_ID].Ns));<br>    float4 ReflectedLight = float4(SceneData[0].materials[mesh_ID].Ks, 1) * Intensity;<br> <br> float shinniness = 60.0; <br>    float specular = pow( dot( Halfvector, inputObj.nrmW ), shinniness ); //float4 reflected = reflect(DirectLight, inputObj.nrmW);<br> //float intensityv = pow(saturate(dot(ViewDir, reflected)), SceneData[0].materials[mesh_ID].Ns);    float4 fLightColor = saturate( DirectLight  + IndirectLight) * (float4(SceneData[0].materials[mesh_ID].Kd, 1) + ReflectedLight + float4(SceneData[0].materials[mesh_ID].Ke , 1)) + pointLight[0];// + pointLight[1];// + specular;<br> //float4 fLightColor = IndirectLight + float4(SceneData[0].sunColor.xyz * SceneData[0].materials[mesh_ID].Ks * intensityv, 0.0f); return fLightColor;<br> <br>}<br>)&quot;; struct GlobalUbo {<br> GW::MATH::GMATRIXF projectionView{ 1.f };<br> //GW::MATH::GVECTORF lightDirection; // = glm::normalize(glm::vec3{ 1.f, -3.f, -1.f });<br> GW::MATH::GVECTORF ambientLightColor{ 1.f, 1.f, 1.f, .02f };  // w is intensity<br> GW::MATH::GVECTORF lightPosition{ -1.f };<br> alignas(16) GW::MATH::GVECTORF lightColor{ 1.f };  // w is light intensity<br> };struct LIGHT {<br> unsigned type = 16;<br> float radius = 2;<br> GW::MATH::GVECTORF pos = { -1,100,0,0 };<br> GW::MATH::GVECTORF color = { 1.f, 1.f, 1.f, .05f };<br> GW::MATH::GVECTORF dir;<br>};struct SHADER_MODEL_DATA<br>{<br> GW::MATH::GVECTORF sunDirection, sunColor, sunAmbient, camPos;//light info<br> GW::MATH::GMATRIXF ViewMatrix, ProjectionMatrix;//view info<br> //<br> GW::MATH::GMATRIXF matricies[MAX_SUBMESH_PER_DRAW];//world sapace<br> //OBJ_ATTRIBUTES materialsf[MAX_SUBMESH_PER_DRAW];<br> H2B::ATTRIBUTES materials[MAX_SUBMESH_PER_DRAW];//color/texture<br> //sampler2D texSampler;<br> //GW::MATH::GVECTORF sunAmbient, camPos;<br> LIGHT light[MAX_SUBMESH_PER_DRAW];<br>};struct Model_Struct {<br> std::string filename;<br> std::string filepath;<br> std::vector&lt;GW::MATH::GMATRIXF&gt; WorldMatrices;<br> H2B::Parser h2bParser;<br>};<br>struct Model_INDEX {<br> unsigned mesh_ID;<br> unsigned wm_ID;<br> unsigned Light_ID;<br>};struct Model_Data<br>{<br> std::vector&lt;H2B::VERTEX&gt; Vertexes;<br> int VertexSize;<br> int IndexSize;<br> std::vector&lt;unsigned&gt; Indexes;<br> std::vector&lt;unsigned&gt; VertexOffsets;<br> std::vector&lt;unsigned&gt; IndexOffsets;<br> std::vector&lt;unsigned&gt; MatrixOffset;<br> std::vector&lt;unsigned&gt; MaterialOffset;<br>};// Vertex layout for this example<br>struct Vertex {<br> float pos[3];<br> float uv[2];<br> float normal[3];<br>};class Renderer<br>{<br> // Instance<br> SHADER_MODEL_DATA ShaderModelData;<br> std::map&lt;std::string, Model_Struct&gt; mapModels;<br> Model_Data ModelData;<br> std::map&lt;std::string, Model_Struct&gt;::iterator iter;<br> Model_INDEX modelIndex;<br> // proxy handles<br> GW::SYSTEM::GWindow win;<br> GW::GRAPHICS::GVulkanSurface vlk;<br> GW::CORE::GEventReceiver shutdown; GW::AUDIO::GMusic GMusic;<br> GW::AUDIO::GSound GSound;<br> GW::AUDIO::GMusic music;<br> GW::AUDIO::GMusic vxfmusic;<br> GW::AUDIO::GAudio GAudio;<br> std::vector&lt;const char*&gt; Songs;<br> GW::AUDIO::GAudio audio;<br> GW::AUDIO::GAudio vxfaudio; GW::INPUT::GInput keyboard;<br> std::chrono::steady_clock::time_point now; int SongChoice = 0;<br> int CurrentLevel = 0;<br> // what we need at a minimum to draw a triangle<br> VkDevice device = nullptr;<br> VkBuffer vertexHandle = nullptr;<br> VkDeviceMemory vertexData = nullptr;<br> // TODO: Part 1g<br> VkBuffer vertexHandle2 = nullptr;<br> VkDeviceMemory vertexData2 = nullptr;<br> // TODO: Part 2c<br> std::vector&lt;VkBuffer&gt; uniformHandle;<br> std::vector&lt;VkDeviceMemory&gt; uniformData;<br> VkShaderModule vertexShader = nullptr;<br> VkShaderModule pixelShader = nullptr;<br> // pipeline settings for drawing (also required).<br> VkPipeline pipeline = nullptr;<br> VkPipelineLayout pipelineLayout = nullptr;<br> // TODO: Part 2e<br> VkDescriptorSetLayout descriptorLayout = nullptr;<br> // TODO: Part 2f<br> VkDescriptorPool descriptorPool = nullptr;<br> //std::vector &lt; VkDescriptorPool&gt; descriptorPool;<br> // TODO: Part 2g<br> std::vector&lt;VkDescriptorSet&gt; descriptorSet;<br> <br> // descriptorset layout for vertex shader so we don&#x27;t need to bind the texture<br> VkDescriptorSetLayout vertexDescriptorLayout = nullptr; <br>‍<br>/***************** KTX+VULKAN TEXTURING VARIABLES ******************/ <br>// what we need at minimum to load/apply one texture<br> ktxVulkanTexture texture; // one per texture<br> VkImageView textureView = nullptr; // one per texture<br> VkSampler textureSampler = nullptr; // can be shared, effects quality &amp; addressing mode<br> // note that unlike uniform buffers, we don&#x27;t need one for each &quot;in-flight&quot; frame<br> VkDescriptorSet textureDescriptorSet = nullptr; // std::vector&lt;&gt; not required // be aware that all pipeline shaders share the same bind points<br> VkDescriptorSetLayout pixelDescriptorLayout = nullptr;<br> // textures can optionally share descriptor sets/pools/layouts with uniform &amp; storage buffers <br> //VkDescriptorPool descriptorPool = nullptr;<br> // pipeline settings for drawing (also required)<br> //VkPipeline pipeline = nullptr;<br> //VkPipelineLayout pipelineLayout = nullptr; std::chrono::steady_clock::time_point tickTime;<br> <br> GW::MATH::GMatrix proxy;<br> GW::MATH::GVector VectorProxy; GW::MATH::GMATRIXF GMatrixW;<br> GW::MATH::GMATRIXF GMatrixV;<br> GW::MATH::GMATRIXF ProjectionMatrix;<br> GW::MATH::GMATRIXF WorldCamera; GW::MATH::GVECTORF LightDirectionVector;<br> GW::MATH::GVECTORF LightColorVector; VkPhysicalDevice physicalDevice = nullptr;<br> //texture and Skybox<br> uint32_t indexCount;<br> VkBuffer vertexHandleT = nullptr;<br> VkDeviceMemory vertexDataT = nullptr;<br> VkShaderModule vertexShaderT = nullptr;<br> VkShaderModule pixelShaderT = nullptr;public:<br> void GEOMETRY_INTIALIZATION()<br> {<br> // Grab the device &amp; physical device so we can allocate some stuff<br> physicalDevice = nullptr;<br> vlk.GetDevice((void**)&amp;device);<br> vlk.GetPhysicalDevice((void**)&amp;physicalDevice); H2B::VERTEX* tempVec = &amp;ModelData.Vertexes[0];<br> GvkHelper::create_buffer(physicalDevice, device, sizeof(*tempVec) * ModelData.Vertexes.size(),<br> VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |<br> VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, &amp;vertexHandle, &amp;vertexData);<br> GvkHelper::write_to_buffer(device, vertexData, &amp;*tempVec, sizeof(*tempVec) * ModelData.Vertexes.size());<br> // TODO: Part 1g<br> unsigned* tempInd = &amp;ModelData.Indexes[0];<br> GvkHelper::create_buffer(physicalDevice, device, sizeof(*tempInd) * ModelData.Indexes.size(),<br> VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |<br> VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, &amp;vertexHandle2, &amp;vertexData2);<br> GvkHelper::write_to_buffer(device, vertexData2, &amp;*tempInd, sizeof(*tempInd) * ModelData.Indexes.size());<br> }<br> void PopulateModel(std::map&lt;std::string, Model_Struct&gt; MeshMap)<br> {<br> int counterMat = 0;<br> int counterV = 0;<br> int counterMatx = 0;<br> int counterI = 0;<br> ModelData.MaterialOffset.push_back(0);<br> ModelData.VertexOffsets.push_back(0);<br> ModelData.MatrixOffset.push_back(0);<br> ModelData.IndexOffsets.push_back(0);<br> for (auto const&amp; it : MeshMap)<br> { //counter sizes<br> counterMat += it.second.h2bParser.materialCount;<br> counterV += it.second.h2bParser.vertices.size();<br> counterMatx += it.second.WorldMatrices.size();<br> counterI += it.second.h2bParser.indices.size();<br> //make offsets<br> ModelData.MaterialOffset.push_back(counterMat);<br> ModelData.VertexOffsets.push_back(counterV);<br> ModelData.MatrixOffset.push_back(counterMatx);<br> ModelData.IndexOffsets.push_back(counterI);<br> //pass V &amp; I<br> ModelData.Vertexes.insert(ModelData.Vertexes.end(), it.second.h2bParser.vertices.begin(), it.second.h2bParser.vertices.end());<br> ModelData.Indexes.insert(ModelData.Indexes.end(), it.second.h2bParser.indices.begin(), it.second.h2bParser.indices.end()); }<br> //sizeof(std::vector&lt;int&gt;) + (sizeof(int) * MyVector.size())<br> ModelData.VertexSize = sizeof(std::vector&lt;H2B::VECTOR&gt;) + (sizeof(H2B::VECTOR) * ModelData.Vertexes.size());<br> ModelData.IndexSize = sizeof(ModelData.Indexes) * ModelData.Indexes.size();<br> }<br> bool ParseFile(const char* file) {<br> int i, y, j;<br> std::string line;<br> std::ifstream myfile(file);<br> std::string delimiter;<br> std::string modelName;<br> GW::MATH::GMATRIXF matrixTranfrom = GW::MATH::GIdentityMatrixF;<br> if (!myfile.is_open()) {<br> std::cout &lt;&lt; &quot;Unable to open file&quot;;<br> return false;<br> }<br> while (std::getline(myfile, line)) {<br> <br> if (line == &quot;MESH&quot;) {<br> i = 0, y = 0, j = 0;<br> std::getline(myfile, line);<br> delimiter = &quot;.&quot;;<br> modelName = line.substr(0, line.find(delimiter));<br> while (y &lt; 4)<br> {<br> std::getline(myfile, line);<br> delimiter = &quot;)&quot;;<br> size_t pos = 0;<br> std::string sentence;<br> line = line.substr(13, (line.find(delimiter) - 13));<br> delimiter = &quot;,&quot;;<br> <br> //Line 1<br> pos = line.find(delimiter);<br> sentence = line.substr(0, pos);<br> matrixTranfrom.data[i] = std::stof(sentence);<br> line.erase(0, pos + delimiter.length());<br> i++;<br> //Line 1<br> pos = line.find(delimiter);<br> sentence = line.substr(0, pos);<br> matrixTranfrom.data[i] = std::stof(sentence);<br> line.erase(0, pos + delimiter.length());<br> i++;<br> //Line 1<br> pos = line.find(delimiter);<br> sentence = line.substr(0, pos);<br> matrixTranfrom.data[i] = std::stof(sentence);<br> line.erase(0, pos + delimiter.length());<br> i++;<br> //Line 1<br> pos = line.find(delimiter);<br> sentence = line.substr(0, pos);<br> matrixTranfrom.data[i] = std::stof(sentence);<br> line.erase(0, pos + delimiter.length());<br> i++; y++;<br> }<br> if (mapModels.find(modelName) == mapModels.end()) {<br> std::string filePath = &quot;../Assests/&quot;;<br> filePath.append(modelName);<br> filePath.append(&quot;.h2b&quot;);<br> Model_Struct transformStruct = { };<br> transformStruct.filename = modelName;<br> transformStruct.filepath = filePath;<br> transformStruct.WorldMatrices = { matrixTranfrom };<br> //transformStruct.h2bParser = filePath;<br> mapModels.insert(std::pair&lt;std::string, Model_Struct&gt;(modelName, transformStruct));<br> mapModels[modelName].h2bParser.Parse(filePath.c_str());<br> }<br> else<br> {<br> mapModels[modelName].WorldMatrices.push_back(matrixTranfrom);<br> }<br> }<br> } PopulateModel(mapModels); myfile.close();<br> return true;<br> }<br> void Music()<br> {<br> audio.Create();<br> music.Create(&quot;../ambience_city.wav&quot;, audio, 0.1);<br> audio.PlayMusic();<br> <br> }<br> <br> Renderer(GW::SYSTEM::GWindow _win, GW::GRAPHICS::GVulkanSurface _vlk)<br> {<br> win = _win;<br> vlk = _vlk;<br> proxy.Create();<br> VectorProxy.Create();<br> keyboard.Create(win);<br> now = std::chrono::steady_clock::now();<br> //loading Music<br> Music();<br> <br> unsigned int width, height;<br> win.GetClientWidth(width);<br> win.GetClientHeight(height);<br> <br> //loading Level<br> ParseFile(&quot;../GameLevel.txt&quot;); GW::MATH::GVECTORF vector = { 0.15f, 0.75f, 0, 0 };<br> proxy.IdentityF(GMatrixW);<br> proxy.RotateXGlobalF(GMatrixW, G2D_DEGREE_TO_RADIAN(90.0), GMatrixW);<br> proxy.TranslateGlobalF(GMatrixW, vector, GMatrixW); //<br> proxy.IdentityF(GMatrixV);<br> //view<br> GW::MATH::GVECTORF YUp = { 0, 1.0f, 0, 0 };<br> GW::MATH::GVECTORF YAtCam = vector;<br> GW::MATH::GVECTORF YEyeVTrans = { 9.75f, 4.25f, -10.5f, 0 };<br> //proxy.TranslateGlobalF(GMatrixV, YEyeVTrans, GMatrixV);<br> proxy.LookAtLHF(YEyeVTrans, YAtCam, YUp, GMatrixV);<br> <br> proxy.InverseF(GMatrixV, WorldCamera);<br> <br> //Projection<br> float AspectRatio;<br> proxy.IdentityF(ProjectionMatrix);<br> //proxy.IdentityF(GMatrixP);<br> vlk.GetAspectRatio(AspectRatio);<br> GW::MATH::GVECTORF NP;<br> GW::MATH::GVECTORF FP;<br> proxy.ProjectionVulkanLHF(G2D_DEGREE_TO_RADIAN(65.0), AspectRatio, 0.1f, 100.0f, ProjectionMatrix);<br> //<br> LightDirectionVector = { -1.0f, -1.0f, 1.0f, 0.0f };<br> VectorProxy.NormalizeF(LightDirectionVector, LightDirectionVector);<br> int lightCount = 2;<br> LIGHT lightValues[MAX_SUBMESH_PER_DRAW] =<br> {<br> { 1,8, { -1,10,5,5 }, { 0.9f, 0.9f, 1.f, 0.7f }, LightDirectionVector },<br> { 2,2, { -1,2,0,0 }, { 0.0f, 0.0f, 0.1f, 0.01f },  { -1.0f, -1.0f, 1.0f, 0.0f } }<br> }; modelIndex.Light_ID = 0;<br> //for (size_t i = 0; i &lt; lightCount; i++)<br> //{<br> // //ligth<br> // ShaderModelData.light[i] = lightValues[i];<br> // //modelIndex.Light_ID = i;<br> //}<br> <br> ////ligth<br> ShaderModelData.light[0].radius = 8;<br> ShaderModelData.light[0].color = { 0.9f, 0.9f, 1.f, 0.7f };<br> ShaderModelData.light[0].pos = { -1,10,5,5 };<br> ShaderModelData.light[0].dir = LightDirectionVector;<br> ShaderModelData.light[1].radius = 2;<br> ShaderModelData.light[1].color = { 0.2f, 0.2f, 1.f, 0.7f };<br> ShaderModelData.light[1].pos = { -1,10,5,5 };<br> ShaderModelData.light[1].dir = LightDirectionVector;<br> LightColorVector = { 0.9f, 0.9f, 1.0f, 1.0f }; // TODO: Part 2b<br> ShaderModelData.matricies[0] = GMatrixW;<br> ShaderModelData.ViewMatrix = GMatrixV;<br> ShaderModelData.camPos = { 0.75f, 0.25f, -1.5f, 1 };<br> ShaderModelData.ProjectionMatrix = ProjectionMatrix;<br> ShaderModelData.sunAmbient = { 0.25f, 0.25f, 0.35f, 1 };<br> ShaderModelData.sunColor = LightColorVector;<br> ShaderModelData.sunDirection = LightDirectionVector;<br> <br> //W &amp; Mat<br> int matId = 0;<br> int matxId = 0;<br> for (auto const&amp; it : mapModels)<br> {<br> for (int y = 0; y &lt; it.second.h2bParser.materialCount; y++)<br> {<br> ShaderModelData.materials[matId] = it.second.h2bParser.materials[y].attrib;<br> matId++;<br> }<br> for (int y = 0; y &lt; it.second.WorldMatrices.size(); y++) <br> {<br> ShaderModelData.matricies[matxId] = it.second.WorldMatrices[y];<br> matxId++;<br> }<br> } /***************** GEOMETRY INTIALIZATION ******************/<br> GEOMETRY_INTIALIZATION(); // TODO: Part 2d<br> unsigned max_frames = 0;<br> // to avoid per-frame resource sharing issues we give each &quot;in-flight&quot; frame its own buffer<br> vlk.GetSwapchainImageCount(max_frames);<br> uniformHandle.resize(max_frames);<br> uniformData.resize(max_frames);<br> for (int i = 0; i &lt; max_frames; ++i) { GvkHelper::create_buffer(physicalDevice, device, sizeof(ShaderModelData),<br> VK_BUFFER_USAGE_STORAGE_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |<br> VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, &amp;uniformHandle[i], &amp;uniformData[i]);<br> GvkHelper::write_to_buffer(device, uniformData[i], &amp;ShaderModelData, sizeof(ShaderModelData));<br> } <br> /***************** SHADER INTIALIZATION ******************/<br> // Intialize runtime shader compiler HLSL -&gt; SPIRV<br> shaderc_compiler_t compiler = shaderc_compiler_initialize();<br> shaderc_compile_options_t options = shaderc_compile_options_initialize();<br> shaderc_compile_options_set_source_language(options, shaderc_source_language_hlsl);<br> shaderc_compile_options_set_invert_y(options, false); // TODO: Part 2i<br>#ifndef NDEBUG<br> shaderc_compile_options_set_generate_debug_info(options);<br>#endif<br> // Create Vertex Shader<br> shaderc_compilation_result_t result = shaderc_compile_into_spv( // compile<br> compiler, vertexShaderSource, strlen(vertexShaderSource),<br> shaderc_vertex_shader, &quot;main.vert&quot;, &quot;main&quot;, options);<br> if (shaderc_result_get_compilation_status(result) != shaderc_compilation_status_success) // errors?<br> std::cout &lt;&lt; &quot;Vertex Shader Errors: &quot; &lt;&lt; shaderc_result_get_error_message(result) &lt;&lt; std::endl;<br> GvkHelper::create_shader_module(device, shaderc_result_get_length(result), // load into Vulkan<br> (char*)shaderc_result_get_bytes(result), &amp;vertexShader);<br> shaderc_result_release(result); // done<br> // Create Pixel Shader<br> result = shaderc_compile_into_spv( // compile<br> compiler, pixelShaderSource, strlen(pixelShaderSource),<br> shaderc_fragment_shader, &quot;main.frag&quot;, &quot;main&quot;, options);<br> if (shaderc_result_get_compilation_status(result) != shaderc_compilation_status_success) // errors?<br> std::cout &lt;&lt; &quot;Pixel Shader Errors: &quot; &lt;&lt; shaderc_result_get_error_message(result) &lt;&lt; std::endl;<br> GvkHelper::create_shader_module(device, shaderc_result_get_length(result), // load into Vulkan<br> (char*)shaderc_result_get_bytes(result), &amp;pixelShader);<br> shaderc_result_release(result); // done<br> // Free runtime shader compiler resources<br> shaderc_compile_options_release(options);<br> shaderc_compiler_release(compiler);#ifndef PIPELINE_INTIALIZATION<br> /***************** PIPELINE INTIALIZATION ******************/<br> // Create Pipeline &amp; Layout (Thanks Tiny!)<br> VkRenderPass renderPass;<br> vlk.GetRenderPass((void**)&amp;renderPass);<br> VkPipelineShaderStageCreateInfo stage_create_info[2] = {};<br> // Create Stage Info for Vertex Shader<br> stage_create_info[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;<br> stage_create_info[0].stage = VK_SHADER_STAGE_VERTEX_BIT;<br> stage_create_info[0].module = vertexShader;<br> stage_create_info[0].pName = &quot;main&quot;;<br> // Create Stage Info for Fragment Shader<br> stage_create_info[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;<br> stage_create_info[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;<br> stage_create_info[1].module = pixelShader;<br> stage_create_info[1].pName = &quot;main&quot;;<br> // Assembly State<br> VkPipelineInputAssemblyStateCreateInfo assembly_create_info = {};<br> assembly_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;<br> assembly_create_info.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;<br> assembly_create_info.primitiveRestartEnable = false;<br> // TODO: Part 1e<br> // Vertex Input State<br> VkVertexInputBindingDescription vertex_binding_description = {};<br> vertex_binding_description.binding = 0;<br> vertex_binding_description.stride = sizeof(H2B::VERTEX);<br> vertex_binding_description.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;<br> VkVertexInputAttributeDescription vertex_attribute_description[3] = {<br> { 0, 0, VK_FORMAT_R32G32B32_SFLOAT, 0 }, //uv, normal, etc.... <br> { 1, 0, VK_FORMAT_R32G32B32_SFLOAT, 12 },<br> { 2, 0, VK_FORMAT_R32G32B32_SFLOAT, 24 }<br> };<br> VkPipelineVertexInputStateCreateInfo input_vertex_info = {};<br> input_vertex_info.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;<br> input_vertex_info.vertexBindingDescriptionCount = 1;<br> input_vertex_info.pVertexBindingDescriptions = &amp;vertex_binding_description;<br> input_vertex_info.vertexAttributeDescriptionCount = 3;<br> input_vertex_info.pVertexAttributeDescriptions = vertex_attribute_description;<br> // Viewport State (we still need to set this up even though we will overwrite the values)<br> VkViewport viewport = {<br> 0, 0, static_cast&lt;float&gt;(width), static_cast&lt;float&gt;(height), 0, 1<br> };<br> VkRect2D scissor = { {0, 0}, {width, height} };<br> VkPipelineViewportStateCreateInfo viewport_create_info = {};<br> viewport_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;<br> viewport_create_info.viewportCount = 1;<br> viewport_create_info.pViewports = &amp;viewport;<br> viewport_create_info.scissorCount = 1;<br> viewport_create_info.pScissors = &amp;scissor;<br> // Rasterizer State<br> VkPipelineRasterizationStateCreateInfo rasterization_create_info = {};<br> rasterization_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;<br> rasterization_create_info.rasterizerDiscardEnable = VK_FALSE;<br> rasterization_create_info.polygonMode = VK_POLYGON_MODE_FILL;<br> rasterization_create_info.lineWidth = 1.0f;<br> rasterization_create_info.cullMode = VK_CULL_MODE_NONE;<br> rasterization_create_info.frontFace = VK_FRONT_FACE_CLOCKWISE;<br> rasterization_create_info.depthClampEnable = VK_FALSE;<br> rasterization_create_info.depthBiasEnable = VK_FALSE;<br> rasterization_create_info.depthBiasClamp = 0.0f;<br> rasterization_create_info.depthBiasConstantFactor = 0.0f;<br> rasterization_create_info.depthBiasSlopeFactor = 0.0f;<br> // Multisampling State<br> VkPipelineMultisampleStateCreateInfo multisample_create_info = {};<br> multisample_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;<br> multisample_create_info.sampleShadingEnable = VK_FALSE;<br> multisample_create_info.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;<br> multisample_create_info.minSampleShading = 1.0f;<br> multisample_create_info.pSampleMask = VK_NULL_HANDLE;<br> multisample_create_info.alphaToCoverageEnable = VK_FALSE;<br> multisample_create_info.alphaToOneEnable = VK_FALSE;<br> // Depth-Stencil State<br> VkPipelineDepthStencilStateCreateInfo depth_stencil_create_info = {};<br> depth_stencil_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;<br> depth_stencil_create_info.depthTestEnable = VK_TRUE;<br> depth_stencil_create_info.depthWriteEnable = VK_TRUE;<br> depth_stencil_create_info.depthCompareOp = VK_COMPARE_OP_LESS;<br> depth_stencil_create_info.depthBoundsTestEnable = VK_FALSE;<br> depth_stencil_create_info.minDepthBounds = 0.0f;<br> depth_stencil_create_info.maxDepthBounds = 1.0f;<br> depth_stencil_create_info.stencilTestEnable = VK_FALSE;<br> // Color Blending Attachment &amp; State<br> VkPipelineColorBlendAttachmentState color_blend_attachment_state = {};<br> color_blend_attachment_state.colorWriteMask = 0xF;<br> color_blend_attachment_state.blendEnable = VK_FALSE;<br> color_blend_attachment_state.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_COLOR;<br> color_blend_attachment_state.dstColorBlendFactor = VK_BLEND_FACTOR_DST_COLOR;<br> color_blend_attachment_state.colorBlendOp = VK_BLEND_OP_ADD;<br> color_blend_attachment_state.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;<br> color_blend_attachment_state.dstAlphaBlendFactor = VK_BLEND_FACTOR_DST_ALPHA;<br> color_blend_attachment_state.alphaBlendOp = VK_BLEND_OP_ADD;<br> VkPipelineColorBlendStateCreateInfo color_blend_create_info = {};<br> color_blend_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;<br> color_blend_create_info.logicOpEnable = VK_FALSE;<br> color_blend_create_info.logicOp = VK_LOGIC_OP_COPY;<br> color_blend_create_info.attachmentCount = 1;<br> color_blend_create_info.pAttachments = &amp;color_blend_attachment_state;<br> color_blend_create_info.blendConstants[0] = 0.0f;<br> color_blend_create_info.blendConstants[1] = 0.0f;<br> color_blend_create_info.blendConstants[2] = 0.0f;<br> color_blend_create_info.blendConstants[3] = 0.0f;<br> // Dynamic State <br> VkDynamicState dynamic_state[2] = {<br> // By setting these we do not need to re-create the pipeline on Resize<br> VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR<br> };<br> VkPipelineDynamicStateCreateInfo dynamic_create_info = {};<br> dynamic_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;<br> dynamic_create_info.dynamicStateCount = 2;<br> dynamic_create_info.pDynamicStates = dynamic_state; /***************** DESCRIPTOR SETUP FOR VERTEX &amp; FRAGMENT SHADERS ******************/ VkDescriptorSetLayoutBinding descriptor_layout_binding = {};<br> descriptor_layout_binding.binding = 0;<br> descriptor_layout_binding.descriptorCount = 1;<br> descriptor_layout_binding.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;<br> // In this scenario we have the same descriptorSetLayout for both shaders...<br> // However, many times you would want seperate layouts for each since they tend to have different needs <br> descriptor_layout_binding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;<br> descriptor_layout_binding.pImmutableSamplers = nullptr;<br> VkDescriptorSetLayoutCreateInfo descriptor_create_info = {};<br> descriptor_create_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;<br> descriptor_create_info.flags = 0;<br> descriptor_create_info.bindingCount = 1;<br> descriptor_create_info.pBindings = &amp;descriptor_layout_binding;<br> descriptor_create_info.pNext = nullptr;<br> // Descriptor layout<br> VkResult r = vkCreateDescriptorSetLayout(device, &amp;descriptor_create_info,<br> nullptr, &amp;descriptorLayout);<br> // Create a descriptor pool!<br> VkDescriptorPoolCreateInfo descriptorpool_create_info = {};<br> descriptorpool_create_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;<br> VkDescriptorPoolSize descriptorpool_size = { VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, max_frames };<br> descriptorpool_create_info.poolSizeCount = 1;<br> descriptorpool_create_info.pPoolSizes = &amp;descriptorpool_size;<br> descriptorpool_create_info.maxSets = max_frames;<br> descriptorpool_create_info.flags = 0;<br> descriptorpool_create_info.pNext = nullptr;<br> vkCreateDescriptorPool(device, &amp;descriptorpool_create_info, nullptr, &amp;descriptorPool);<br> // Create a descriptorSet for each uniform buffer!<br> VkDescriptorSetAllocateInfo descriptorset_allocate_info = {};<br> descriptorset_allocate_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;<br> descriptorset_allocate_info.descriptorSetCount = 1;<br> descriptorset_allocate_info.pSetLayouts = &amp;descriptorLayout;<br> descriptorset_allocate_info.descriptorPool = descriptorPool;<br> descriptorset_allocate_info.pNext = nullptr;<br> descriptorSet.resize(max_frames);<br> for (int i = 0; i &lt; max_frames; ++i) {<br> vkAllocateDescriptorSets(device, &amp;descriptorset_allocate_info, &amp;descriptorSet[i]);<br> }<br> // link our descriptor sets to our uniform buffers (one for each bufferimage)<br> // you can do this later on too for switching buffers, just don&#x27;t expect rendering frames to wait<br> VkWriteDescriptorSet write_descriptorset = {};<br> write_descriptorset.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;<br> write_descriptorset.descriptorCount = 1;<br> write_descriptorset.dstArrayElement = 0;<br> write_descriptorset.dstBinding = 0;<br> write_descriptorset.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;<br> for (int i = 0; i &lt; max_frames; ++i) {<br> write_descriptorset.dstSet = descriptorSet[i];<br> VkDescriptorBufferInfo dbinfo = { uniformHandle[i], 0, VK_WHOLE_SIZE };<br> write_descriptorset.pBufferInfo = &amp;dbinfo;<br> vkUpdateDescriptorSets(device, 1, &amp;write_descriptorset, 0, nullptr);<br> } VkPushConstantRange PCR2 = {};<br> PCR2.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;<br> //PCR2.offset = 0;<br> PCR2.size = sizeof(Model_INDEX); // Descriptor pipeline layout<br> VkPipelineLayoutCreateInfo pipeline_layout_create_info = {};<br> pipeline_layout_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;<br> pipeline_layout_create_info.setLayoutCount = 1;<br> pipeline_layout_create_info.pSetLayouts = &amp;descriptorLayout;<br> pipeline_layout_create_info.pushConstantRangeCount = 1;<br> pipeline_layout_create_info.pPushConstantRanges = &amp;PCR2;<br> vkCreatePipelineLayout(device, &amp;pipeline_layout_create_info, nullptr, &amp;pipelineLayout); VkGraphicsPipelineCreateInfo pipeline_create_info = {};<br> pipeline_create_info.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;<br> pipeline_create_info.stageCount = 2;<br> pipeline_create_info.pStages = stage_create_info;<br> pipeline_create_info.pInputAssemblyState = &amp;assembly_create_info;<br> pipeline_create_info.pVertexInputState = &amp;input_vertex_info;<br> pipeline_create_info.pViewportState = &amp;viewport_create_info;<br> pipeline_create_info.pRasterizationState = &amp;rasterization_create_info;<br> pipeline_create_info.pMultisampleState = &amp;multisample_create_info;<br> pipeline_create_info.pDepthStencilState = &amp;depth_stencil_create_info;<br> pipeline_create_info.pColorBlendState = &amp;color_blend_create_info;<br> pipeline_create_info.pDynamicState = &amp;dynamic_create_info;<br> pipeline_create_info.layout = pipelineLayout;<br> pipeline_create_info.renderPass = renderPass;<br> pipeline_create_info.subpass = 0;<br> pipeline_create_info.basePipelineHandle = VK_NULL_HANDLE;<br> vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1,<br> &amp;pipeline_create_info, nullptr, &amp;pipeline);<br>#endif // With pipeline created, lets load in our texture and bind it to our descriptor set<br> //LoadTextures(&quot;../../Textures/greendragon.ktx&quot;); /***************** CLEANUP / SHUTDOWN ******************/<br> // GVulkanSurface will inform us when to release any allocated resources<br> shutdown.Create(vlk, [&amp;]() {<br> if (+shutdown.Find(GW::GRAPHICS::GVulkanSurface::Events::RELEASE_RESOURCES, true)) {<br> CleanUp(); // unlike D3D we must be careful about destroy timing<br> }<br> });<br> } /***************** KTX TEXTURE LOADING &amp; VULKAN SAMPLER/IMGVIEW CREATION ******************/ // ideally this would take multiple/all textures you want to load<br> bool LoadTextures(const char* texturePath)<br> {<br> // Gateware, access to underlying Vulkan queue and command pool &amp; physical device<br> VkQueue graphicsQueue;<br> VkCommandPool cmdPool;<br> VkPhysicalDevice physicalDevice;<br> vlk.GetGraphicsQueue((void**)&amp;graphicsQueue);<br> vlk.GetCommandPool((void**)&amp;cmdPool);<br> vlk.GetPhysicalDevice((void**)&amp;physicalDevice);<br> // libktx, temporary variables<br> ktxTexture* kTexture;<br> KTX_error_code ktxresult;<br> ktxVulkanDeviceInfo vdi;<br> // used to transfer texture CPU memory to GPU. just need one<br> ktxresult = ktxVulkanDeviceInfo_Construct(&amp;vdi, physicalDevice, device,<br> graphicsQueue, cmdPool, nullptr);<br> if (ktxresult != KTX_error_code::KTX_SUCCESS)<br> return false;<br> // load texture into CPU memory from file<br> ktxresult = ktxTexture_CreateFromNamedFile(texturePath,<br> KTX_TEXTURE_CREATE_NO_FLAGS, &amp;kTexture);<br> if (ktxresult != KTX_error_code::KTX_SUCCESS)<br> return false;<br> // This gets mad if you don&#x27;t encode/save the .ktx file in a format Vulkan likes<br> ktxresult = ktxTexture_VkUploadEx(kTexture, &amp;vdi, &amp;texture,<br> VK_IMAGE_TILING_OPTIMAL,<br> VK_IMAGE_USAGE_SAMPLED_BIT,<br> VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);<br> if (ktxresult != KTX_error_code::KTX_SUCCESS)<br> return false;<br> // after loading all textures you don&#x27;t need these anymore<br> ktxTexture_Destroy(kTexture);<br> ktxVulkanDeviceInfo_Destruct(&amp;vdi); // create the the image view and sampler<br> VkSamplerCreateInfo samplerInfo = {};<br> // Set the struct values<br> samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;<br> samplerInfo.flags = 0;<br> samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER; // REPEAT IS COMMON<br> samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;<br> samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;<br> samplerInfo.magFilter = VK_FILTER_LINEAR;<br> samplerInfo.minFilter = VK_FILTER_LINEAR;<br> samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;<br> samplerInfo.mipLodBias = 0;<br> samplerInfo.minLod = 0;<br> samplerInfo.maxLod = texture.levelCount;<br> samplerInfo.anisotropyEnable = VK_FALSE;<br> samplerInfo.maxAnisotropy = 1.0;<br> samplerInfo.borderColor = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;<br> samplerInfo.compareEnable = VK_FALSE;<br> samplerInfo.compareOp = VK_COMPARE_OP_LESS;<br> samplerInfo.unnormalizedCoordinates = VK_FALSE;<br> samplerInfo.pNext = nullptr;<br> VkResult vr = vkCreateSampler(device, &amp;samplerInfo, nullptr, &amp;textureSampler);<br> if (vr != VkResult::VK_SUCCESS)<br> return false; // Create image view.<br> // Textures are not directly accessed by the shaders and are abstracted<br> // by image views containing additional information and sub resource ranges.<br> VkImageViewCreateInfo viewInfo = {};<br> // Set the non-default values.<br> viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;<br> viewInfo.flags = 0;<br> viewInfo.components = {<br> VK_COMPONENT_SWIZZLE_R, VK_COMPONENT_SWIZZLE_G,<br> VK_COMPONENT_SWIZZLE_B, VK_COMPONENT_SWIZZLE_A<br> };<br> viewInfo.image = texture.image;<br> viewInfo.format = texture.imageFormat;<br> viewInfo.viewType = texture.viewType;<br> viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;<br> viewInfo.subresourceRange.layerCount = texture.layerCount;<br> viewInfo.subresourceRange.levelCount = texture.levelCount;<br> viewInfo.subresourceRange.baseMipLevel = 0;<br> viewInfo.subresourceRange.baseArrayLayer = 0;<br> viewInfo.pNext = nullptr;<br> vr = vkCreateImageView(device, &amp;viewInfo, nullptr, &amp;textureView);<br> if (vr != VkResult::VK_SUCCESS)<br> return false; // update the descriptor set(s) to point to the correct views<br> VkWriteDescriptorSet write_descriptorset = {};<br> write_descriptorset.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;<br> write_descriptorset.descriptorCount = 1;<br> write_descriptorset.dstArrayElement = 0;<br> write_descriptorset.dstBinding = 1;<br> write_descriptorset.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;<br> write_descriptorset.dstSet = textureDescriptorSet;<br> VkDescriptorImageInfo diinfo = { textureSampler, textureView, texture.imageLayout };<br> write_descriptorset.pImageInfo = &amp;diinfo;<br> vkUpdateDescriptorSets(device, 1, &amp;write_descriptorset, 0, nullptr); return true;<br> } void Render()<br> {<br> //Variables<br> int offSet = 0;<br> unsigned counter = 1; unsigned int currentBuffer;<br> vlk.GetSwapchainCurrentImage(currentBuffer);<br> VkCommandBuffer commandBuffer;<br> vlk.GetCommandBuffer(currentBuffer, (void**)&amp;commandBuffer);<br> // what is the current client area dimensions?<br> unsigned int width, height;<br> win.GetClientWidth(width);<br> win.GetClientHeight(height);<br> // setup the pipeline&#x27;s dynamic settings<br> VkViewport viewport = {<br> 0, 0, static_cast&lt;float&gt;(width), static_cast&lt;float&gt;(height), 0, 1<br> };<br> VkRect2D scissor = { {0, 0}, {width, height} };<br> vkCmdSetViewport(commandBuffer, 0, 1, &amp;viewport);<br> vkCmdSetScissor(commandBuffer, 0, 1, &amp;scissor);<br> vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);<br> // now we can draw<br> VkDeviceSize offsets[] = { 0 }; vkCmdBindVertexBuffers(commandBuffer, 0, 1, &amp;vertexHandle, offsets);<br> vkCmdBindIndexBuffer(commandBuffer, vertexHandle2, *offsets, VK_INDEX_TYPE_UINT32); GvkHelper::write_to_buffer(device, uniformData[currentBuffer], &amp;ShaderModelData, sizeof(ShaderModelData));<br> /***************** BINDING OF UNIFORM BUFFER VIA DESCRIPTORSET ******************/ // *NEW* Set the descriptorSet that contains the uniform buffer allocated for this framebuffer vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,<br> pipelineLayout, 0, 1, &amp;descriptorSet[currentBuffer], 0, nullptr); /*for (size_t i = 0; i &lt; FSLogo_materialcount; i++)<br> {<br> vkCmdPushConstants(commandBuffer, pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT,<br> 0, sizeof(unsigned), &amp;i);<br> vkCmdDrawIndexed(commandBuffer, FSLogo_meshes[i].indexCount, 1, FSLogo_meshes[i].indexOffset, 0, 0);<br> }*/ /***************** BINDING OF TEXTURE DESCRIPTOR SET TO PIXEL SHADER ******************/ // *NEW* Set the descriptorSet that contains our texture<br> //vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,<br> //pipelineLayout, 1, 1, &amp;textureDescriptorSet, 0, nullptr);<br> <br> for (iter = mapModels.begin(); iter != mapModels.end(); ++iter, offSet++) <br> {<br> for (unsigned i = 0; i &lt; iter-&gt;second.h2bParser.meshCount; i++)<br> {<br> <br> modelIndex.mesh_ID = ModelData.MaterialOffset[offSet] + iter-&gt;second.h2bParser.meshes[i].materialIndex;<br> modelIndex.wm_ID = counter;<br> //modelIndex.Light_ID = counter;<br> <br> vkCmdPushConstants(commandBuffer, pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof(Model_INDEX), &amp;modelIndex);<br> vkCmdDrawIndexed(commandBuffer, iter-&gt;second.h2bParser.meshes[i].drawInfo.indexCount, iter-&gt;second.WorldMatrices.size(), ModelData.IndexOffsets[offSet] + iter-&gt;second.h2bParser.meshes[i].drawInfo.indexOffset, ModelData.VertexOffsets[offSet], ModelData.MatrixOffset[offSet]);<br> //vkCmdDrawIndexed(commandBuffer, it-&gt;second.h2bParser.meshes[i].drawInfo.indexCount, 1,  it-&gt;second.h2bParser.meshes[i].drawInfo.indexOffset, VertexOffsets[offSet], 0);<br> }<br> }<br> } void clearUp()<br> {<br> vkDeviceWaitIdle(device);<br> vkFreeMemory(device, vertexData, nullptr);<br> vkDestroyBuffer(device, vertexHandle, nullptr);<br> vkFreeMemory(device, vertexData2, nullptr);<br> vkDestroyBuffer(device, vertexHandle2, nullptr);<br> mapModels.clear();<br> ModelData.Vertexes.clear();<br> ModelData.Indexes.clear();<br> ModelData.IndexOffsets.clear();<br> ModelData.VertexOffsets.clear();<br> ModelData.MaterialOffset.clear();<br> ModelData.MatrixOffset.clear();<br> } void changeLevel() {<br> <br> clearUp(); if (CurrentLevel == 0) {<br> ParseFile(&quot;../GameLevel2.txt&quot;);<br> CurrentLevel = 1;<br> }<br> else {<br> ParseFile(&quot;../GameLevel.txt&quot;);<br> CurrentLevel = 0;<br> }<br> //W &amp; Mat<br> int matId = 0;<br> int matxId = 0;<br> for (auto const&amp; it : mapModels)<br> {<br> for (int y = 0; y &lt; it.second.h2bParser.materialCount; y++)<br> {<br> ShaderModelData.materials[matId] = it.second.h2bParser.materials[y].attrib;<br> matId++;<br> }<br> for (int y = 0; y &lt; it.second.WorldMatrices.size(); y++)<br> {<br> ShaderModelData.matricies[matxId] = it.second.WorldMatrices[y];<br> matxId++;<br> }<br> } GEOMETRY_INTIALIZATION();<br> } void Input()<br> {<br> static bool LevelChange = true;<br> float R;<br> keyboard.GetState(55, R);<br> static bool LevelChanged;<br> <br> if (LevelChange &amp;&amp; !LevelChanged) {<br> LevelChange = false;<br> changeLevel();<br> LevelChanged = true;<br> }<br> if (R == 0)<br> {<br> LevelChange = false;<br> LevelChanged = false;<br> } <br> else <br> {<br> LevelChange = true;<br> } if (GetAsyncKeyState(&#x27;F&#x27;))<br> {<br> vxfaudio.Create();<br> vxfmusic.Create(&quot;../door_open.wav&quot;, vxfaudio, 0.5);<br> vxfaudio.PlayMusic();<br> } } void UpdateCamera()<br> { proxy.InverseF(ShaderModelData.ViewMatrix, WorldCamera); //InputVariables<br> float aspectratio = 0;<br> unsigned height, width;<br> vlk.GetAspectRatio(aspectratio);<br> win.GetHeight(height);<br> win.GetWidth(width);<br> const float camera_speed = 1.0f; //Keybord Input<br> float spacebar = 0;<br> float leftShift = 0;<br> keyboard.GetState(23, spacebar);<br> keyboard.GetState(14, leftShift);<br> float Y_Change = spacebar - leftShift;<br> //Movement<br> float A = 0;<br> float W = 0;<br> float S = 0;<br> float D = 0;<br> keyboard.GetState(60, W);<br> keyboard.GetState(56, S);<br> keyboard.GetState(41, D);<br> keyboard.GetState(38, A);<br> float totalZ = W - S;<br> float totalX = D - A; //Mouse Input<br> float MYAxis = 0;<br> float MXAxis = 0;<br> float total_pitch = 0;<br> float total_yaw = 0;<br> GW::GReturn returnValue = GW::GReturn::FAILURE;;<br> returnValue = keyboard.GetMouseDelta(MXAxis, MYAxis); //Tick Time<br> auto tickTimeEnd = std::chrono::steady_clock::now();<br> std::chrono::duration&lt;float&gt; delta = tickTimeEnd - tickTime;<br> tickTime = tickTimeEnd;<br> float fps = camera_speed * delta.count() * 4;<br> float Total_Y_Change = Y_Change * 500 * fps * delta.count(); //Add Keyboard Movement<br> GW::MATH::GVECTORF vectorGUpDown = { 0.0f,Total_Y_Change,0.0f,1.0f };<br> GW::MATH::GVECTORF vectorMovement = { totalX * fps, 0, totalZ * fps };<br> proxy.TranslateGlobalF(WorldCamera, vectorGUpDown, WorldCamera);<br> proxy.TranslateLocalF(WorldCamera, vectorMovement, WorldCamera); //Add Mouse Movement<br> if (returnValue == GW::GReturn::SUCCESS)<br> {<br> total_pitch = total_pitch + 1.13446f * MYAxis / height;<br> total_yaw = total_yaw + 1.13446f * aspectratio * MXAxis / width;<br> }<br> GW::MATH::GMATRIXF pitch;<br> GW::MATH::GMATRIXF yaw;<br> proxy.IdentityF(pitch);<br> proxy.RotateYGlobalF(WorldCamera, total_yaw, WorldCamera);<br> //proxy.MultiplyMatrixF(pitch, WorldCamera, WorldCamera);<br> proxy.IdentityF(yaw);<br> proxy.RotateXLocalF(WorldCamera, total_pitch, WorldCamera);<br> //proxy.MultiplyMatrixF(WorldCamera, yaw, WorldCamera); proxy.InverseF(WorldCamera, ShaderModelData.ViewMatrix); };<br> <br>private:<br> void CleanUp()<br> {<br> // wait till everything has completed<br> vkDeviceWaitIdle(device);<br> // Release allocated buffers, shaders &amp; pipeline<br> // // When done using the image in Vulkan...<br> /*ktxVulkanTexture_Destruct(&amp;texture, device, nullptr);<br> if (textureView) {<br> vkDestroyImageView(device, textureView, nullptr);<br> textureView = nullptr;<br> }<br> if (textureSampler) {<br> vkDestroySampler(device, textureSampler, nullptr);<br> textureSampler = nullptr;<br> }*/<br> // TODO: Part 1g<br> vkDestroyBuffer(device, vertexHandle2, nullptr);<br> vkFreeMemory(device, vertexData2, nullptr);<br> // TODO: Part 2d<br> for (int i = 0; i &lt; uniformHandle.size(); i++) {<br> vkDestroyBuffer(device, uniformHandle[i], nullptr);<br> vkFreeMemory(device, uniformData[i], nullptr);<br> //vkDestroyDescriptorPool(device, descriptorPool, nullptr);<br> }<br> uniformHandle.clear();<br> uniformData.clear();<br> vkDestroyBuffer(device, vertexHandle, nullptr);<br> vkFreeMemory(device, vertexData, nullptr);<br> vkDestroyShaderModule(device, vertexShader, nullptr);<br> vkDestroyShaderModule(device, pixelShader, nullptr); vkDestroyDescriptorSetLayout(device, descriptorLayout, nullptr);<br> // don&#x27;t need the descriptors anymore<br> //vkDestroyDescriptorSetLayout(device, vertexDescriptorLayout, nullptr);<br> //vkDestroyDescriptorSetLayout(device, pixelDescriptorLayout, nullptr);<br> vkDestroyDescriptorPool(device, descriptorPool, nullptr);<br> vkDestroyPipelineLayout(device, pipelineLayout, nullptr);<br> vkDestroyPipeline(device, pipeline, nullptr);<br> }<br>};<br></p>
        </div>
      </nav>
    </div>
    <section id="Features" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Programming Explanation</strong></h2>
    </section>
    <div class="container-7 w-container">
      <div class="rich-text-block-5 curses heading-curses ed w-richtext">
        <p><strong>Vulkan Levels Render</strong></p>
        <ul role="list">
          <li>The primary goal of the project is to apply all that I learned in the VulkanAPI course to create software designed to draw the visual aspects of a gamelevel. </li>
        </ul>
        <ul role="list">
          <li>In the project learn aboutimporting external graphics data(3D models) onto the graphics card by carefullyfollowing the rule of three. Normally one would read a 3D model format usingFile I/O or use an external API to accessthis type of data. In the interest of time, we will use a custom tool called obj2headerto covert an .obj model file to a header file containing our 3D model data.</li>
        </ul>
        <ul role="list">
          <li>In addition to importing ourvertex and index data, we will also import material data for use by our pixelshader. Materials are information representing how a surface is supposed tobehave/react when interacting with light. We will learn how to import this datain the form of a uniform buffer and then have it respond to a directional lightsource with a specular component.</li>
        </ul>
      </div><img src="../images/Vulkan_Leve1.JPG" loading="lazy" sizes="(max-width: 479px) 96vw, (max-width: 767px) 97vw, (max-width: 991px) 728px, 810px" srcset="../images/Vulkan_Leve1-p-500.jpeg 500w, ../images/Vulkan_Leve1.JPG 810w" alt="image">
      <div class="rich-text-block-5 curses heading-curses ed w-richtext">
        <p><strong>Controls</strong></p>
        <ul role="list">
          <li>WASD – move the camera</li>
          <li>Mouse to pick up and drag entities</li>
          <li>PGUP/PGDN – Change the Camera Mode</li>
          <li>Keys R will toggle viewing Level Render</li>
        </ul>
        <p>‍</p>
      </div>
      <div class="feature-image-mask"></div>
    </div>
  </div>
  <div class="section-2 footer background-black wf-section">
    <div class="container-4 w-container">
      <div class="footer-holder">
        <div class="social-wrapper">
          <a href="https://juan_diego_lugo.artstation.com" target="_blank" class="social-link w-inline-block"><img src="../images/Artstation.png" loading="lazy" alt="" class="image-13"></a>
          <a href="https://github.com/JDMAXilius" target="_blank" class="social-link w-inline-block"><img src="../images/github.png" loading="lazy" alt="image" class="image-13"></a>
          <a href="https://www.youtube.com/channel/UCRjr5hvDeIpc_SfgTO690RA/featured" target="_blank" class="social-link w-inline-block"><img src="../images/youtube.png" loading="lazy" alt="" class="image-13"></a>
          <a href="#" class="social-link w-inline-block"><img src="../images/pngfind.com-discord-icon-png-283551.png" loading="lazy" srcset="../images/pngfind.com-discord-icon-png-283551-p-500.png 500w, ../images/pngfind.com-discord-icon-png-283551-p-800.png 800w, ../images/pngfind.com-discord-icon-png-283551-p-1080.png 1080w, ../images/pngfind.com-discord-icon-png-283551.png 1468w" sizes="40px" alt="" class="image-13"></a>
          <a href="https://www.facebook.com/juandiego.lugo1" target="_blank" class="social-link w-inline-block"><img src="../images/fb.png" loading="lazy" alt="" class="image-13 f"></a>
          <a href="#" class="social-link w-inline-block"><img src="../images/Instagram.svg" loading="lazy" alt="Instagram logo" class="image-13"></a>
          <a href="https://www.linkedin.com/in/juan-diego-lugo-929a34205/" class="social-link w-inline-block"><img src="../images/LinkedIn.svg" loading="lazy" alt="LinkedIn logo" class="image-14"></a>
        </div><img src="https://uploads-ssl.webflow.com/602ca53e736379cc95d5f180/602ca53e58ea7fb6bb114f5c_Logo.svg" loading="lazy" width="187" alt="" class="image">
        <div class="text-block-3">@Juan Diego 2021<br>‍</div>
      </div>
    </div>
  </div>
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=602f42d4d0eb6ddf9136273c" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="../js/webflow.js" type="text/javascript"></script>
  <!-- [if lte IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/placeholders/3.0.2/placeholders.min.js"></script><![endif] -->
</body>
</html>