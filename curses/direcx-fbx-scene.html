<!DOCTYPE html><!--  This site was created in Webflow. https://www.webflow.com  -->
<!--  Last Published: Sat Sep 10 2022 03:50:01 GMT+0000 (Coordinated Universal Time)  -->
<html data-wf-page="62261dbc4669f6514680999e" data-wf-site="602f42d4d0eb6ddf9136273c">
<head>
  <meta charset="utf-8">
  <title>DirecX FBX Scene</title>
  <meta content="DirecX FBX Scene" property="og:title">
  <meta content="DirecX FBX Scene" property="twitter:title">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="Webflow" name="generator">
  <link href="../css/normalize.css" rel="stylesheet" type="text/css">
  <link href="../css/webflow.css" rel="stylesheet" type="text/css">
  <link href="../css/juan-diegos-portfolio.webflow.css" rel="stylesheet" type="text/css">
  <!-- [if lt IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" type="text/javascript"></script><![endif] -->
  <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <link href="../images/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <link href="../images/webclip.png" rel="apple-touch-icon">
</head>
<body class="body">
  <div data-w-id="ff3ac0b1-c979-2917-beb2-e00e39f97f07" data-animation="over-right" data-collapse="medium" data-duration="400" data-easing="ease" data-easing2="ease" role="banner" class="navbar-3 w-nav">
    <div class="container-8 w-container">
      <a href="../index.html" class="nav-logo-link"><img src="../images/Logo-Name-Portfolio.png" alt="IMAGE" class="nav-logo"></a>
      <nav role="navigation" class="nav-menu-3 w-nav-menu">
        <a href="../index.html" class="nav-link home works w-nav-link">HOME</a>
        <a href="#" class="nav-link home works w-nav-link">SUMMARY</a>
        <a href="#" class="nav-link home works w-nav-link">FEATURES</a>
        <a href="#" class="nav-link home works code w-nav-link">CODE</a>
        <a href="#" class="nav-link home works w-nav-link">DESIGN</a>
      </nav>
      <div class="menu-button-2 w-nav-button">
        <div class="w-icon-nav-menu"></div>
      </div>
    </div>
  </div>
  <div class="section background-black curses wf-section">
    <div class="centered-container-7 this w-container">
      <h1 class="heading-curses this">DirecX FBX Scene</h1>
      <p class="paragraph-5 curses">The primary goal of the project is to apply all that I learned in the Vulkan API course to create software designed to draw the visual aspects of a gamelevel. <br></p>
      <div class="div-block-24">
        <div class="rich-text-block-4 w-richtext">
          <p> <strong>Software Used</strong>   </p>
          <p><strong>Languages Used </strong>  </p>
        </div>
        <div class="rich-text-block-3 w-richtext">
          <p>Visual Studio</p>
          <p>C++</p>
        </div>
      </div>
    </div>
    <div class="div-block-32 dl curses">
      <div class="text-block-11">Feel Free to Download the Source Code.</div>
      <a href="https://github.com/JDMAXilius/DirecX_FBX_Scene" target="_blank" class="button-6 ds w-button">Source Code</a>
    </div>
    <div class="container-7 w-container">
      <h2 class="heading-26-curse-2"><strong>Project Content<br></strong></h2>
      <p class="paragrahps-2 blog colum curses new"><strong>FBX Object <br></strong>Maye file<br>FBX file<br>texture file<br>dds file<strong><br></strong></p>
    </div>
    <section id="Features" class="flex-container line curses w-container"></section>
    <section id="Code" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Programming Code</strong></h2>
    </section>
    <div data-hover="false" data-delay="0" class="dropdown-2 w-dropdown">
      <div data-w-id="6d698fcd-3d73-34e6-a87b-2a5a413ece4b" class="dropdown-toggle-2 w-dropdown-toggle">
        <div data-w-id="6d698fcd-3d73-34e6-a87b-2a5a413ece4c" class="icon accordion-icon w-icon-dropdown-toggle"></div>
        <div class="text-block-13">Development Code</div>
      </div>
      <nav class="dropdown-list-2 w-dropdown-list">
        <div class="flex-container-grid this w-container">
          <p class="code-text">‍<strong>Code<br>‍<br>‍</strong>HRESULT InitWindow(HINSTANCE hInstance, int nCmdShow)<br>{<br> // Register class<br> WNDCLASSEX wcex;<br> wcex.cbSize = sizeof(WNDCLASSEX);<br> wcex.style = CS_HREDRAW | CS_VREDRAW;<br> wcex.lpfnWndProc = WndProc;<br> wcex.cbClsExtra = 0;<br> wcex.cbWndExtra = 0;<br> wcex.hInstance = hInstance;<br> wcex.hIcon = LoadIcon(hInstance, (LPCTSTR)IDI_TUTORIAL1);<br> wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);<br> wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);<br> wcex.lpszMenuName = nullptr;<br> wcex.lpszClassName = L&quot;TutorialWindowClass&quot;;<br> wcex.hIconSm = LoadIcon(wcex.hInstance, (LPCTSTR)IDI_TUTORIAL1);<br> if (!RegisterClassEx(&amp;wcex))<br> return E_FAIL; // Create window<br> g_hInst = hInstance;<br> RECT rc = { 0, 0, 1024, 768 };<br> AdjustWindowRect(&amp;rc, WS_OVERLAPPEDWINDOW, FALSE);<br> g_hWnd = CreateWindow(L&quot;TutorialWindowClass&quot;, L&quot;Direct3D 11 Simple Viewer&quot;,<br> WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,<br> CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, nullptr, nullptr, hInstance,<br> nullptr);<br> if (!g_hWnd)<br> return E_FAIL; ShowWindow(g_hWnd, nCmdShow); return S_OK;<br>}void InitDebugTexture()<br>{<br> static const uint32_t s_pixel = 0xffffffff; D3D11_SUBRESOURCE_DATA initData = { &amp;s_pixel, sizeof(uint32_t), 0 }; D3D11_TEXTURE2D_DESC desc = {};<br> desc.Width = desc.Height = desc.MipLevels = desc.ArraySize = 1;<br> desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;<br> desc.SampleDesc.Count = 1;<br> desc.Usage = D3D11_USAGE_IMMUTABLE;<br> desc.BindFlags = D3D11_BIND_SHADER_RESOURCE; ComPtr&lt;ID3D11Texture2D&gt; tex;<br> HRESULT hr = g_pd3dDevice-&gt;CreateTexture2D(&amp;desc, &amp;initData, tex.GetAddressOf()); if (SUCCEEDED(hr))<br> {<br> D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc = {};<br> SRVDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;<br> SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;<br> SRVDesc.Texture2D.MipLevels = 1; hr = g_pd3dDevice-&gt;CreateShaderResourceView(tex.Get(),<br> &amp;SRVDesc, texSRV.GetAddressOf());<br> }<br> assert(!FAILED(hr));<br>}void InitRasterizerStates()<br>{<br> D3D11_RASTERIZER_DESC rasterDesc;<br> ZeroMemory(&amp;rasterDesc, sizeof(rasterDesc)); rasterDesc.AntialiasedLineEnable = true;<br> rasterDesc.CullMode = D3D11_CULL_NONE;<br> rasterDesc.DepthBias = 0;<br> rasterDesc.DepthBiasClamp = 0.0f;<br> rasterDesc.DepthClipEnable = true;<br> rasterDesc.FillMode = D3D11_FILL_WIREFRAME;<br> rasterDesc.FrontCounterClockwise = false;<br> rasterDesc.MultisampleEnable = false;<br> rasterDesc.ScissorEnable = false;<br> rasterDesc.SlopeScaledDepthBias = 0.0f; HRESULT hr = g_pd3dDevice-&gt;CreateRasterizerState(&amp;rasterDesc, &amp;rasterStateWireframe);<br> assert(!FAILED(hr)); ZeroMemory(&amp;rasterDesc, sizeof(rasterDesc)); rasterDesc.AntialiasedLineEnable = false;<br> rasterDesc.CullMode = D3D11_CULL_BACK;<br> rasterDesc.DepthBias = 0;<br> rasterDesc.DepthBiasClamp = 0.0f;<br> rasterDesc.DepthClipEnable = true;<br> rasterDesc.FillMode = D3D11_FILL_SOLID;<br> rasterDesc.FrontCounterClockwise = false;<br> rasterDesc.MultisampleEnable = false;<br> rasterDesc.ScissorEnable = false;<br> rasterDesc.SlopeScaledDepthBias = 0.0f; hr = g_pd3dDevice-&gt;CreateRasterizerState(&amp;rasterDesc, &amp;rasterStateDefault);<br> assert(!FAILED(hr)); ZeroMemory(&amp;rasterDesc, sizeof(rasterDesc)); rasterDesc.AntialiasedLineEnable = false;<br> rasterDesc.CullMode = D3D11_CULL_NONE;<br> rasterDesc.DepthBias = 0;<br> rasterDesc.DepthBiasClamp = 0.0f;<br> rasterDesc.DepthClipEnable = true;<br> rasterDesc.FillMode = D3D11_FILL_SOLID;<br> rasterDesc.FrontCounterClockwise = false;<br> rasterDesc.MultisampleEnable = false;<br> rasterDesc.ScissorEnable = false;<br> rasterDesc.SlopeScaledDepthBias = 0.0f; hr = g_pd3dDevice-&gt;CreateRasterizerState(&amp;rasterDesc, &amp;rasterStateFillNoCull);<br> assert(!FAILED(hr));<br>}void InitDepthStates()<br>{<br> D3D11_DEPTH_STENCIL_DESC dsDesc; // Depth test parameters<br> dsDesc.DepthEnable = true;<br> dsDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;<br> dsDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;// D3D11_COMPARISON_LESS; // Stencil test parameters<br> dsDesc.StencilEnable = true;<br> dsDesc.StencilReadMask = 0xFF;<br> dsDesc.StencilWriteMask = 0xFF; // Stencil operations if pixel is front-facing<br> dsDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;<br> dsDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;<br> dsDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;<br> dsDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS; // Stencil operations if pixel is back-facing<br> dsDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;<br> dsDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;<br> dsDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;<br> dsDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS; // Create depth stencil state<br> g_pd3dDevice-&gt;CreateDepthStencilState(&amp;dsDesc, &amp;pDSStateNoWrite);<br> // g_pImmediateContext-&gt;OMSetDepthStencilState(pDSStateNoWrite, 1); // Depth test parameters<br> dsDesc.DepthEnable = true;<br> dsDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;<br> dsDesc.DepthFunc = D3D11_COMPARISON_LESS; // Stencil test parameters<br> dsDesc.StencilEnable = true;<br> dsDesc.StencilReadMask = 0xFF;<br> dsDesc.StencilWriteMask = 0xFF; // Stencil operations if pixel is front-facing<br> dsDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;<br> dsDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;<br> dsDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;<br> dsDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS; // Stencil operations if pixel is back-facing<br> dsDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;<br> dsDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;<br> dsDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;<br> dsDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS; // Create depth stencil state<br> g_pd3dDevice-&gt;CreateDepthStencilState(&amp;dsDesc, &amp;pDSState);<br> // g_pImmediateContext-&gt;OMSetDepthStencilState(pDSStateNoWrite, 1);<br>}HRESULT InitSkybox()<br>{<br> HRESULT hr = S_OK; //////////////////////////////////////////<br> //Create mesh render components<br> //////////////////////////////////////////<br> {<br> // Generate the geometry<br> SimpleMesh&lt;SimpleVertex&gt; mesh;<br> MeshUtils::makeCubePNT(mesh); // Create the vertex buffers from the generated SimpleMesh<br> hr = skyboxRenderable.CreateBuffers(<br> g_pd3dDevice,<br> mesh.indicesList,<br> (float*)mesh.vertexList.data(),<br> sizeof(SimpleVertex),<br> mesh.vertexList.size()); // Load the Texture<br> std::string filename = &quot;sunsetcube1024.dds&quot;;<br> hr = skyboxRenderable.CreateTextureFromFile(g_pd3dDevice, filename);<br> if (FAILED(hr))<br> return hr; // Create the sampler state<br> hr = skyboxRenderable.CreateDefaultSampler(g_pd3dDevice); // Define the input layout<br> D3D11_INPUT_ELEMENT_DESC layout[] =<br> {<br> { &quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;NORMAL&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;TEXCOORD&quot;, 0, DXGI_FORMAT_R32G32_FLOAT, 0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> }; // Create the shaders<br> hr = skyboxRenderable.CreateVertexShaderAndInputLayoutFromFile(g_pd3dDevice, &quot;Skybox_VS.cso&quot;, layout, ARRAYSIZE(layout));<br> hr = skyboxRenderable.CreatePixelShaderFromFile(g_pd3dDevice, &quot;Skybox_PS.cso&quot;); // Create the shader constant buffer<br> hr = skyboxRenderable.CreateConstantBufferVS(g_pd3dDevice, sizeof(TransformsConstantBuffer));<br> }<br> return hr;<br>}void InitBlendState()<br>{<br> //Define the Blending Equation<br> D3D11_BLEND_DESC blendDesc;<br> ZeroMemory(&amp;blendDesc, sizeof(blendDesc)); D3D11_RENDER_TARGET_BLEND_DESC rtbd;<br> ZeroMemory(&amp;rtbd, sizeof(rtbd)); rtbd.BlendEnable = true;<br> int ALPHA_MODE = 1;<br> switch (ALPHA_MODE)<br> {<br> case 0: // object alpha<br> {<br> rtbd.SrcBlend = D3D11_BLEND_SRC_ALPHA;<br> rtbd.DestBlend = D3D11_BLEND_INV_SRC_ALPHA;<br> blendDesc.AlphaToCoverageEnable = false;<br> break;<br> }<br> case 1: // pixel alpha<br> {<br> rtbd.SrcBlend = D3D11_BLEND_SRC_ALPHA;<br> rtbd.DestBlend = D3D11_BLEND_INV_SRC_ALPHA;<br> blendDesc.AlphaToCoverageEnable = true;<br> break;<br> }<br> case 2: // additive (emissive)<br> {<br> rtbd.SrcBlend = D3D11_BLEND_ONE;<br> rtbd.DestBlend = D3D11_BLEND_ONE;<br> blendDesc.AlphaToCoverageEnable = false;<br> break;<br> }<br> }<br> rtbd.BlendOp = D3D11_BLEND_OP_ADD;<br> rtbd.SrcBlendAlpha = D3D11_BLEND_ONE;<br> rtbd.DestBlendAlpha = D3D11_BLEND_ZERO;<br> rtbd.BlendOpAlpha = D3D11_BLEND_OP_ADD;<br> rtbd.RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL; blendDesc.RenderTarget[0] = rtbd;<br> g_pd3dDevice-&gt;CreateBlendState(&amp;blendDesc, &amp;transparencyState);<br>}//--------------------------------------------------------------------------------------<br>// Create Direct3D device and swap chain<br>//--------------------------------------------------------------------------------------<br>HRESULT InitDevice()<br>{<br> HRESULT hr = S_OK; RECT rc;<br> GetClientRect(g_hWnd, &amp;rc);<br> UINT width = rc.right - rc.left;<br> UINT height = rc.bottom - rc.top; UINT createDeviceFlags = 0;<br>#ifdef _DEBUG<br> createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;<br>#endif D3D_DRIVER_TYPE driverTypes[] =<br> {<br> D3D_DRIVER_TYPE_HARDWARE,<br> D3D_DRIVER_TYPE_WARP,<br> D3D_DRIVER_TYPE_REFERENCE,<br> };<br> UINT numDriverTypes = ARRAYSIZE(driverTypes); D3D_FEATURE_LEVEL featureLevels[] =<br> {<br> D3D_FEATURE_LEVEL_11_1,<br> D3D_FEATURE_LEVEL_11_0,<br> D3D_FEATURE_LEVEL_10_1,<br> D3D_FEATURE_LEVEL_10_0,<br> };<br> UINT numFeatureLevels = ARRAYSIZE(featureLevels); for (UINT driverTypeIndex = 0; driverTypeIndex &lt; numDriverTypes; driverTypeIndex++)<br> {<br> g_driverType = driverTypes[driverTypeIndex];<br> hr = D3D11CreateDevice(nullptr, g_driverType, nullptr, createDeviceFlags, featureLevels, numFeatureLevels,<br> D3D11_SDK_VERSION, &amp;g_pd3dDevice, &amp;g_featureLevel, &amp;g_pImmediateContext); if (hr == E_INVALIDARG)<br> {<br> // DirectX 11.0 platforms will not recognize D3D_FEATURE_LEVEL_11_1 so we need to retry without it<br> hr = D3D11CreateDevice(nullptr, g_driverType, nullptr, createDeviceFlags, &amp;featureLevels[1], numFeatureLevels - 1,<br> D3D11_SDK_VERSION, &amp;g_pd3dDevice, &amp;g_featureLevel, &amp;g_pImmediateContext);<br> } if (SUCCEEDED(hr))<br> break;<br> }<br> if (FAILED(hr))<br> return hr; // Obtain DXGI factory from device (since we used nullptr for pAdapter above)<br> IDXGIFactory1* dxgiFactory = nullptr;<br> {<br> IDXGIDevice* dxgiDevice = nullptr;<br> hr = g_pd3dDevice-&gt;QueryInterface(__uuidof(IDXGIDevice), reinterpret_cast&lt;void**&gt;(&amp;dxgiDevice));<br> if (SUCCEEDED(hr))<br> {<br> IDXGIAdapter* adapter = nullptr;<br> hr = dxgiDevice-&gt;GetAdapter(&amp;adapter);<br> if (SUCCEEDED(hr))<br> {<br> hr = adapter-&gt;GetParent(__uuidof(IDXGIFactory1), reinterpret_cast&lt;void**&gt;(&amp;dxgiFactory));<br> adapter-&gt;Release();<br> }<br> dxgiDevice-&gt;Release();<br> }<br> }<br> if (FAILED(hr))<br> return hr; // Create swap chain<br> IDXGIFactory2* dxgiFactory2 = nullptr;<br> hr = dxgiFactory-&gt;QueryInterface(__uuidof(IDXGIFactory2), reinterpret_cast&lt;void**&gt;(&amp;dxgiFactory2));<br> if (dxgiFactory2)<br> {<br> // DirectX 11.1 or later<br> hr = g_pd3dDevice-&gt;QueryInterface(__uuidof(ID3D11Device1), reinterpret_cast&lt;void**&gt;(&amp;g_pd3dDevice1));<br> if (SUCCEEDED(hr))<br> {<br> (void)g_pImmediateContext-&gt;QueryInterface(__uuidof(ID3D11DeviceContext1), reinterpret_cast&lt;void**&gt;(&amp;g_pImmediateContext1));<br> } DXGI_SWAP_CHAIN_DESC1 sd = {};<br> sd.Width = width;<br> sd.Height = height;<br> sd.Format = DXGI_FORMAT_R8G8B8A8_UNORM;<br> sd.SampleDesc.Count = 1;<br> sd.SampleDesc.Quality = 0;<br> sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;<br> sd.BufferCount = 1; hr = dxgiFactory2-&gt;CreateSwapChainForHwnd(g_pd3dDevice, g_hWnd, &amp;sd, nullptr, nullptr, &amp;g_pSwapChain1);<br> if (SUCCEEDED(hr))<br> {<br> hr = g_pSwapChain1-&gt;QueryInterface(__uuidof(IDXGISwapChain), reinterpret_cast&lt;void**&gt;(&amp;g_pSwapChain));<br> } dxgiFactory2-&gt;Release();<br> }<br> else<br> {<br> // DirectX 11.0 systems<br> DXGI_SWAP_CHAIN_DESC sd = {};<br> sd.BufferCount = 1;<br> sd.BufferDesc.Width = width;<br> sd.BufferDesc.Height = height;<br> sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;<br> sd.BufferDesc.RefreshRate.Numerator = 60;<br> sd.BufferDesc.RefreshRate.Denominator = 1;<br> sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;<br> sd.OutputWindow = g_hWnd;<br> sd.SampleDesc.Count = 1;<br> sd.SampleDesc.Quality = 0;<br> sd.Windowed = TRUE; hr = dxgiFactory-&gt;CreateSwapChain(g_pd3dDevice, &amp;sd, &amp;g_pSwapChain);<br> } // Note this tutorial doesn&#x27;t handle full-screen swapchains so we block the ALT+ENTER shortcut<br> dxgiFactory-&gt;MakeWindowAssociation(g_hWnd, DXGI_MWA_NO_ALT_ENTER); dxgiFactory-&gt;Release(); if (FAILED(hr))<br> return hr; // Create a render target view<br> ID3D11Texture2D* pBackBuffer = nullptr;<br> hr = g_pSwapChain-&gt;GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast&lt;void**&gt;(&amp;pBackBuffer));<br> if (FAILED(hr))<br> return hr; hr = g_pd3dDevice-&gt;CreateRenderTargetView(pBackBuffer, nullptr, &amp;g_pRenderTargetView);<br> pBackBuffer-&gt;Release();<br> if (FAILED(hr))<br> return hr; // Create depth stencil texture<br> D3D11_TEXTURE2D_DESC descDepth = {};<br> descDepth.Width = width;<br> descDepth.Height = height;<br> descDepth.MipLevels = 1;<br> descDepth.ArraySize = 1;<br> descDepth.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;<br> descDepth.SampleDesc.Count = 1;<br> descDepth.SampleDesc.Quality = 0;<br> descDepth.Usage = D3D11_USAGE_DEFAULT;<br> descDepth.BindFlags = D3D11_BIND_DEPTH_STENCIL;<br> descDepth.CPUAccessFlags = 0;<br> descDepth.MiscFlags = 0;<br> hr = g_pd3dDevice-&gt;CreateTexture2D(&amp;descDepth, nullptr, &amp;g_pDepthStencil);<br> if (FAILED(hr))<br> return hr; // Create the depth stencil view<br> D3D11_DEPTH_STENCIL_VIEW_DESC descDSV = {};<br> descDSV.Format = descDepth.Format;<br> descDSV.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;<br> descDSV.Texture2D.MipSlice = 0;<br> hr = g_pd3dDevice-&gt;CreateDepthStencilView(g_pDepthStencil, &amp;descDSV, &amp;g_pDepthStencilView);<br> if (FAILED(hr))<br> return hr; g_pImmediateContext-&gt;OMSetRenderTargets(1, &amp;g_pRenderTargetView, g_pDepthStencilView); // Setup the viewport<br> D3D11_VIEWPORT vp;<br> vp.Width = (FLOAT)width;<br> vp.Height = (FLOAT)height;<br> vp.MinDepth = 0.0f;<br> vp.MaxDepth = 1.0f;<br> vp.TopLeftX = 0;<br> vp.TopLeftY = 0;<br> g_pImmediateContext-&gt;RSSetViewports(1, &amp;vp); // Initialize the projection matrix<br> g_Projection = XMMatrixPerspectiveFovLH(XM_PIDIV4, width / (FLOAT)height, 0.01f, 1000.0f); return hr;<br>}<br>HRESULT InitContent()<br>{<br> InitDebugTexture();<br> InitRasterizerStates();<br> InitDepthStates();<br> InitSkybox();<br> InitBlendState();<br> InitFBX(); //modelViewProjection = new ConstantBufferTransforms(); HRESULT hr = S_OK; //////////////////////////////////////////<br> //Create mesh render components<br> //////////////////////////////////////////<br> {<br> Renderable meshRenderable; // Generate the geometry<br> SimpleMesh&lt;SimpleVertex&gt; mesh; // filename for texture file<br> std::string filename; // Load it!<br> //LoadFBX(&quot;.//Assets//cube.fbx&quot;, mesh, filename);<br> LoadFBX(&quot;.//Assets//scene_03.fbx&quot;, mesh, filename); // Create the vertex buffers from the generated SimpleMesh<br> hr = meshRenderable.CreateBuffers(<br> g_pd3dDevice,<br> mesh.indicesList,<br> (float*)mesh.vertexList.data(),<br> sizeof(SimpleVertex),<br> mesh.vertexList.size()); // Load the Texture when texture filename is valid<br> if (filename != &quot;&quot;)<br> { <br> hr = meshRenderable.CreateTextureFromFile(g_pd3dDevice, &quot;.//Assets//&quot; +filename);<br> if (FAILED(hr))<br> return hr; // Create the sampler state<br> hr = meshRenderable.CreateDefaultSampler(g_pd3dDevice);<br> } // Define the input layout<br> D3D11_INPUT_ELEMENT_DESC layout[] =<br> {<br> { &quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;NORMAL&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;TEXCOORD&quot;, 0, DXGI_FORMAT_R32G32_FLOAT, 0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> }; // Create the shaders<br> hr = meshRenderable.CreateVertexShaderAndInputLayoutFromFile(g_pd3dDevice, &quot;Tutorial06_VS.cso&quot;, layout, ARRAYSIZE(layout));<br> hr = meshRenderable.CreatePixelShaderFromFile(g_pd3dDevice, &quot;Tutorial06_PS.cso&quot;); // Create the shader constant buffer<br> hr = meshRenderable.CreateConstantBufferVS(g_pd3dDevice, sizeof(TransformsConstantBuffer));<br> hr = meshRenderable.CreateConstantBufferPS(g_pd3dDevice, sizeof(LightsConstantBuffer));<br> meshRenderable.setPosition(-2.0f, 0.0f, 0.0f);<br> renderables.push_back(meshRenderable);<br> /*meshRenderable.setPosition(2.0f, 0.0f, 0.0f);<br> meshRenderable.setRotation(XMMatrixRotationY(3.14159265359f));<br> renderables.push_back(meshRenderable);*/ }<br> //////////////////////////////////////////<br>//Create mesh render components<br>//////////////////////////////////////////<br> {<br> Renderable meshRenderable; // Generate the geometry<br> SimpleMesh&lt;SimpleVertex&gt; mesh; // filename for texture file<br> std::string filename; // Load it!<br> //LoadFBX(&quot;.//Assets//cube.fbx&quot;, mesh, filename);<br> LoadFBX(&quot;.//Assets//scene_02.fbx&quot;, mesh, filename); // Create the vertex buffers from the generated SimpleMesh<br> hr = meshRenderable.CreateBuffers(<br> g_pd3dDevice,<br> mesh.indicesList,<br> (float*)mesh.vertexList.data(),<br> sizeof(SimpleVertex),<br> mesh.vertexList.size()); // Load the Texture when texture filename is valid<br> if (filename != &quot;&quot;)<br> {<br> hr = meshRenderable.CreateTextureFromFile(g_pd3dDevice, &quot;.//Assets//&quot; +filename);<br> if (FAILED(hr))<br> return hr; // Create the sampler state<br> hr = meshRenderable.CreateDefaultSampler(g_pd3dDevice);<br> } // Define the input layout<br> D3D11_INPUT_ELEMENT_DESC layout[] =<br> {<br> { &quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;NORMAL&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;TEXCOORD&quot;, 0, DXGI_FORMAT_R32G32_FLOAT, 0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> }; // Create the shaders<br> hr = meshRenderable.CreateVertexShaderAndInputLayoutFromFile(g_pd3dDevice, &quot;Tutorial06_VS.cso&quot;, layout, ARRAYSIZE(layout));<br> hr = meshRenderable.CreatePixelShaderFromFile(g_pd3dDevice, &quot;Tutorial06_PS.cso&quot;); // Create the shader constant buffer<br> hr = meshRenderable.CreateConstantBufferVS(g_pd3dDevice, sizeof(TransformsConstantBuffer));<br> hr = meshRenderable.CreateConstantBufferPS(g_pd3dDevice, sizeof(LightsConstantBuffer));<br> meshRenderable.setPosition(-2.0f, 0.0f, 0.0f);<br> renderables.push_back(meshRenderable);<br> /*meshRenderable.setPosition(2.0f, 0.0f, 0.0f);<br> meshRenderable.setRotation(XMMatrixRotationY(3.14159265359f));<br> renderables.push_back(meshRenderable);*/ }<br> //////////////////////////////////////////<br> //Create mesh render components<br> //////////////////////////////////////////<br> {<br> Renderable meshRenderable; // Generate the geometry<br> SimpleMesh&lt;SimpleVertex&gt; mesh; // filename for texture file<br> std::string filename; // Load it!<br> //LoadFBX(&quot;.//Assets//cube.fbx&quot;, mesh, filename);<br> LoadFBX(&quot;.//Assets//scene_01.fbx&quot;, mesh, filename); // Create the vertex buffers from the generated SimpleMesh<br> hr = meshRenderable.CreateBuffers(<br> g_pd3dDevice,<br> mesh.indicesList,<br> (float*)mesh.vertexList.data(),<br> sizeof(SimpleVertex),<br> mesh.vertexList.size()); // Load the Texture when texture filename is valid<br> if (filename != &quot;&quot;)<br> {<br> hr = meshRenderable.CreateTextureFromFile(g_pd3dDevice, &quot;.//Assets//&quot; + filename);<br> if (FAILED(hr))<br> return hr; // Create the sampler state<br> hr = meshRenderable.CreateDefaultSampler(g_pd3dDevice);<br> } // Define the input layout<br> D3D11_INPUT_ELEMENT_DESC layout[] =<br> {<br> { &quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;NORMAL&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;TEXCOORD&quot;, 0, DXGI_FORMAT_R32G32_FLOAT, 0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> }; // Create the shaders<br> hr = meshRenderable.CreateVertexShaderAndInputLayoutFromFile(g_pd3dDevice, &quot;Tutorial06_VS.cso&quot;, layout, ARRAYSIZE(layout));<br> hr = meshRenderable.CreatePixelShaderFromFile(g_pd3dDevice, &quot;Tutorial06_PS.cso&quot;); // Create the shader constant buffer<br> hr = meshRenderable.CreateConstantBufferVS(g_pd3dDevice, sizeof(TransformsConstantBuffer));<br> hr = meshRenderable.CreateConstantBufferPS(g_pd3dDevice, sizeof(LightsConstantBuffer));<br> meshRenderable.setPosition(-2.0f, 0.0f, 0.0f);<br> // Deg to Rad -&gt; val * 3.14 / 180<br> //meshRenderable.setRotation(XMMatrixRotationY(3.14/2));<br> renderables.push_back(meshRenderable);<br> }<br> //////////////////////////////////////////<br>//Create mesh render components<br>//////////////////////////////////////////<br> {<br> Renderable meshRenderable; // Generate the geometry<br> SimpleMesh&lt;SimpleVertex&gt; mesh; // filename for texture file<br> std::string filename; // Load it!<br> //LoadFBX(&quot;.//Assets//cube.fbx&quot;, mesh, filename);<br> LoadFBX(&quot;.//Assets//objects.fbx&quot;, mesh, filename); // Create the vertex buffers from the generated SimpleMesh<br> hr = meshRenderable.CreateBuffers(<br> g_pd3dDevice,<br> mesh.indicesList,<br> (float*)mesh.vertexList.data(),<br> sizeof(SimpleVertex),<br> mesh.vertexList.size()); // Load the Texture when texture filename is valid<br> if (filename != &quot;&quot;)<br> {<br> hr = meshRenderable.CreateTextureFromFile(g_pd3dDevice, &quot;.//Assets//&quot; + filename);<br> if (FAILED(hr))<br> return hr; // Create the sampler state<br> hr = meshRenderable.CreateDefaultSampler(g_pd3dDevice);<br> } // Define the input layout<br> D3D11_INPUT_ELEMENT_DESC layout[] =<br> {<br> { &quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;NORMAL&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;TEXCOORD&quot;, 0, DXGI_FORMAT_R32G32_FLOAT, 0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> }; // Create the shaders<br> hr = meshRenderable.CreateVertexShaderAndInputLayoutFromFile(g_pd3dDevice, &quot;Tutorial06_VS.cso&quot;, layout, ARRAYSIZE(layout));<br> hr = meshRenderable.CreatePixelShaderFromFile(g_pd3dDevice, &quot;Tutorial06_PS.cso&quot;); // Create the shader constant buffer<br> hr = meshRenderable.CreateConstantBufferVS(g_pd3dDevice, sizeof(TransformsConstantBuffer));<br> hr = meshRenderable.CreateConstantBufferPS(g_pd3dDevice, sizeof(LightsConstantBuffer));<br> meshRenderable.setPosition(-2.0f, 0.0f, 0.0f);<br> renderables.push_back(meshRenderable);<br> /*meshRenderable.setPosition(2.0f, 0.0f, 0.0f);<br> meshRenderable.setRotation(XMMatrixRotationY(3.14159265359f));<br> renderables.push_back(meshRenderable);*/ } //////////////////////////////////////////<br>//Create mesh render components<br>//////////////////////////////////////////<br> {<br> Renderable meshRenderable; // Generate the geometry<br> SimpleMesh&lt;SimpleVertex&gt; mesh; // filename for texture file<br> std::string filename; // Load it!<br> //LoadFBX(&quot;.//Assets//cube.fbx&quot;, mesh, filename);<br> LoadFBX(&quot;.//Assets//scene_01.fbx&quot;, mesh, filename); // Create the vertex buffers from the generated SimpleMesh<br> hr = meshRenderable.CreateBuffers(<br> g_pd3dDevice,<br> mesh.indicesList,<br> (float*)mesh.vertexList.data(),<br> sizeof(SimpleVertex),<br> mesh.vertexList.size()); // Load the Texture when texture filename is valid<br> if (filename != &quot;&quot;)<br> {<br> //hr = meshRenderable.CreateTextureFromFile(g_pd3dDevice, &quot;.//Assets//&quot; + filename);<br> if (FAILED(hr))<br> return hr; // Create the sampler state<br> hr = meshRenderable.CreateDefaultSampler(g_pd3dDevice);<br> } // Define the input layout<br> D3D11_INPUT_ELEMENT_DESC layout[] =<br> {<br> { &quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;NORMAL&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;TEXCOORD&quot;, 0, DXGI_FORMAT_R32G32_FLOAT, 0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> }; // Create the shaders<br> hr = meshRenderable.CreateVertexShaderAndInputLayoutFromFile(g_pd3dDevice, &quot;Tutorial06_VS.cso&quot;, layout, ARRAYSIZE(layout));<br> hr = meshRenderable.CreatePixelShaderFromFile(g_pd3dDevice, &quot;Tutorial06_PS.cso&quot;); // Create the shader constant buffer<br> hr = meshRenderable.CreateConstantBufferVS(g_pd3dDevice, sizeof(TransformsConstantBuffer));<br> hr = meshRenderable.CreateConstantBufferPS(g_pd3dDevice, sizeof(LightsConstantBuffer));<br> meshRenderable.setPosition(-2.0f, 0.0f, 0.0f);<br> // Deg to Rad -&gt; val * 3.14 / 180<br> //meshRenderable.setRotation(XMMatrixRotationY(3.14/2));<br> renderables.push_back(meshRenderable);<br> }<br> {<br> Renderable meshRenderable;<br> // Generate the geometry<br> SimpleMesh&lt;SimpleVertex&gt; mesh2;<br> // Set up a crate<br> //MeshUtils::makeCubePNT(mesh2);<br> //std::string filename2 = &quot;crate.dds&quot;; // Set up a bush<br> MeshUtils::makeCrossHatchPNT(mesh2, 0.25f);<br> std::string filename = &quot;grass.dds&quot;;<br> //std::string filename = &quot;spark.dds&quot;; //ground texture<br> //MeshUtils::makeGroundPNT(mesh);<br> //std::string filename = &quot;ground.dds&quot;;<br> //cubes<br> // Create the vertex buffers from the generated SimpleMesh<br> hr = meshRenderable.CreateBuffers(<br> g_pd3dDevice,<br> mesh2.indicesList,<br> (float*)mesh2.vertexList.data(),<br> sizeof(SimpleVertex),<br> mesh2.vertexList.size()); // Load the Texture<br> hr = meshRenderable.CreateTextureFromFile(g_pd3dDevice, filename);<br> if (FAILED(hr))<br> return hr;<br> //<br>// Create the sampler state<br> hr = meshRenderable.CreateDefaultSampler(g_pd3dDevice); // Define the input layout<br> D3D11_INPUT_ELEMENT_DESC layout[] =<br> {<br> { &quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;NORMAL&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> { &quot;TEXCOORD&quot;, 0, DXGI_FORMAT_R32G32_FLOAT, 0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },<br> }; // Create the shaders<br> hr = meshRenderable.CreateVertexShaderAndInputLayoutFromFile(g_pd3dDevice, &quot;Tutorial06_VS.cso&quot;, layout, ARRAYSIZE(layout));<br> hr = meshRenderable.CreatePixelShaderFromFile(g_pd3dDevice, &quot;Tutorial06_PS.cso&quot;); // Create the shader constant buffer<br> hr = meshRenderable.CreateConstantBufferVS(g_pd3dDevice, sizeof(TransformsConstantBuffer));<br> hr = meshRenderable.CreateConstantBufferPS(g_pd3dDevice, sizeof(LightsConstantBuffer));<br> meshRenderable.setPosition(-3.0f, 0.0f, 0.0f);<br> renderables.push_back(meshRenderable);<br> meshRenderable.setPosition(4.0f, 0.0f, 1.0f);<br> renderables.push_back(meshRenderable); meshRenderable.setPosition(-4.0f, 0.0f, 4.0f);<br> renderables.push_back(meshRenderable);<br> meshRenderable.setPosition(2.0f, 0.0f, 5.0f);<br> renderables.push_back(meshRenderable); meshRenderable.setPosition(-14.0f, 0.0f, 14.0f);<br> renderables.push_back(meshRenderable);<br> meshRenderable.setPosition(12.0f, 0.0f, 15.0f);<br> renderables.push_back(meshRenderable);<br> } // Create grid render components<br> {<br> // Generate the geometry<br> DebugLines lines;<br> LineUtils::MakeGrid(lines); // Create the vertex buffers from the lines vector<br> hr = gridRenderable.CreateVertexBuffer(g_pd3dDevice, (float*)lines.vertexList.data(), sizeof(ColorVertex), (int)lines.vertexList.size()); gridRenderable.primitiveTopology = D3D11_PRIMITIVE_TOPOLOGY_LINELIST; // Define the input layout<br> D3D11_INPUT_ELEMENT_DESC lineLayoutDesc[] =<br> {<br> {&quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0},<br> {&quot;COLOR&quot;, 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0}<br> }; // Create the shaders<br> hr = gridRenderable.CreateVertexShaderAndInputLayoutFromFile(g_pd3dDevice, &quot;Debug_VS.cso&quot;, lineLayoutDesc, ARRAYSIZE(lineLayoutDesc));<br> hr = gridRenderable.CreatePixelShaderFromFile(g_pd3dDevice, &quot;Debug_PS.cso&quot;); // Create the shader constant buffer<br> hr = gridRenderable.CreateConstantBufferVS(g_pd3dDevice, sizeof(TransformsConstantBuffer));<br> } // load and create the pixel shader for the light markers<br> auto ps_blob = load_binary_blob(&quot;PSSolid.cso&quot;);<br> hr = g_pd3dDevice-&gt;CreatePixelShader(ps_blob.data(), ps_blob.size(), nullptr, &amp;g_pPixelShaderSolid);<br> if (FAILED(hr))<br> return hr; g_pImmediateContext-&gt;RSSetState(rasterStateDefault); return S_OK;<br>}//--------------------------------------------------------------------------------------<br>// Clean up the objects we&#x27;ve created<br>//--------------------------------------------------------------------------------------<br>void CleanupDevice()<br>{<br> if (g_pImmediateContext) g_pImmediateContext-&gt;ClearState();<br> if (rasterStateDefault) rasterStateDefault-&gt;Release();<br> if (rasterStateWireframe) rasterStateWireframe-&gt;Release();<br> if (rasterStateFillNoCull) rasterStateFillNoCull-&gt;Release();<br> if (g_pPixelShaderSolid) g_pPixelShaderSolid-&gt;Release();<br> if (g_pDepthStencil) g_pDepthStencil-&gt;Release();<br> if (g_pDepthStencilView) g_pDepthStencilView-&gt;Release();<br> if (g_pRenderTargetView) g_pRenderTargetView-&gt;Release();<br> if (g_pSwapChain1) g_pSwapChain1-&gt;Release();<br> if (g_pSwapChain) g_pSwapChain-&gt;Release();<br> if (g_pImmediateContext1) g_pImmediateContext1-&gt;Release();<br> if (g_pImmediateContext) g_pImmediateContext-&gt;Release();<br> if (g_pd3dDevice1) g_pd3dDevice1-&gt;Release();<br> if (g_pd3dDevice) g_pd3dDevice-&gt;Release();<br> if (pDSState) pDSState-&gt;Release();<br> if (pDSStateNoWrite) pDSStateNoWrite-&gt;Release();<br> if (transparencyState) transparencyState-&gt;Release();}<br>//--------------------------------------------------------------------------------------<br>// Called every time the application receives a message<br>//--------------------------------------------------------------------------------------<br>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<br>{<br> PAINTSTRUCT ps;<br> HDC hdc; switch (message)<br> {<br> case WM_PAINT:<br> hdc = BeginPaint(hWnd, &amp;ps);<br> EndPaint(hWnd, &amp;ps);<br> break; case WM_DESTROY:<br> PostQuitMessage(0);<br> break; case WM_KEYDOWN:<br> switch (wParam)<br> {<br> case &#x27;1&#x27;:<br> cout &lt;&lt; &quot;Keypressed - 1&quot; &lt;&lt; endl;<br> // toggle wireframe state<br> RENDER_STYLE_WIREFRAME = !RENDER_STYLE_WIREFRAME;<br> cout &lt;&lt; &quot;RENDER_STYLE_WIREFRAME: &quot; &lt;&lt; RENDER_STYLE_WIREFRAME &lt;&lt; endl;<br> break;<br> case &#x27;2&#x27;:<br> cout &lt;&lt; &quot;Keypressed - 2&quot; &lt;&lt; endl;<br> // toggle textured state<br> RENDER_STYLE_TEXTURED = !RENDER_STYLE_TEXTURED;<br> cout &lt;&lt; &quot;RENDER_STYLE_TEXTURED: &quot; &lt;&lt; RENDER_STYLE_TEXTURED &lt;&lt; endl;<br> break;<br> case &#x27;3&#x27;:<br> cout &lt;&lt; &quot;Keypressed - 3&quot; &lt;&lt; endl;<br> // toggle alpha blending state<br> RENDER_STYLE_TRANSPARENCY = !RENDER_STYLE_TRANSPARENCY;<br> cout &lt;&lt; &quot;RENDER_STYLE_TRANSPARENCY: &quot; &lt;&lt; RENDER_STYLE_TRANSPARENCY &lt;&lt; endl;<br> break;<br> case &#x27;4&#x27;:<br> cout &lt;&lt; &quot;Keypressed - 4&quot; &lt;&lt; endl;<br> // toggle cull front/none state<br> RASTER_FILL_CULL_NONE = !RASTER_FILL_CULL_NONE;<br> cout &lt;&lt; &quot;RASTER_FILL_CULL_NONE: &quot; &lt;&lt; RASTER_FILL_CULL_NONE &lt;&lt; endl;<br> break;<br> case &#x27;5&#x27;:<br> cout &lt;&lt; &quot;Keypressed - 5&quot; &lt;&lt; endl;<br> // toggle cull front/none state<br> DEPTH_WRITE_ENABLED = !DEPTH_WRITE_ENABLED;<br> cout &lt;&lt; &quot;DEPTH_WRITE_ENABLED: &quot; &lt;&lt; DEPTH_WRITE_ENABLED &lt;&lt; endl;<br> break;<br> case &#x27;0&#x27;:<br> cout &lt;&lt; &quot;Keypressed - 0&quot; &lt;&lt; endl;<br> // toggle skybox<br> SKYBOX_ENABLED = !SKYBOX_ENABLED;<br> cout &lt;&lt; &quot;SKYBOX_ENABLED: &quot; &lt;&lt; SKYBOX_ENABLED &lt;&lt; endl;<br> break;<br> }<br> break; default:<br> return DefWindowProc(hWnd, message, wParam, lParam);<br> } return 0;<br>}XMFLOAT4 vLightDirs[2] =<br>{<br> XMFLOAT4(-0.577f, 0.577f, -0.577f, 1.0f),<br> XMFLOAT4(0.0f, 0.0f, -1.0f, 1.0f),<br>};<br>XMFLOAT4 vLightColors[2] =<br>{<br> XMFLOAT4(0.75f, 0.75f, 0.75f, 1.0f),<br> XMFLOAT4(1.0f, 0.0f, 0.0f, 1.0f)<br>};//--------------------------------------------------------------------------------------<br>// Update<br>//--------------------------------------------------------------------------------------<br>void Update()<br>{<br> // Update our time<br> static float t = 0.0f;<br> if (g_driverType == D3D_DRIVER_TYPE_REFERENCE)<br> {<br> t += (float)XM_PI * 0.0125f;<br> }<br> else<br> {<br> static ULONGLONG timeStart = 0;<br> ULONGLONG timeCur = GetTickCount64();<br> if (timeStart == 0)<br> timeStart = timeCur;<br> t = (timeCur - timeStart) / 1000.0f;<br> } // Rotate cube around the origin<br> g_World = XMMatrixRotationY(0);///////<br> // Initialize the world matrices<br> //g_World = XMMatrixIdentity(); // Initialize the view matrix<br> // Stationary camera<br> XMVECTOR Eye = XMVectorSet(8.0f, 4.0f, 10.0f, 0.0f);<br> // Orbit camera<br> //XMVECTOR Eye = XMVectorSet(cos(t / 2) * 10, 4.0f, sin(t / 2) * 10, 0.0f);<br> XMVECTOR At = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);<br> XMVECTOR Up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);<br> g_View = XMMatrixLookAtLH(Eye, At, Up);<br> // Setup our lighting parameters<br> XMStoreFloat4(&amp;vLightDirs[0], { -0.577f, 0.577f, -0.577f, 1.0f });<br> XMStoreFloat4(&amp;vLightDirs[1], { 0.577f, 0.2577f, -0.577f, 1.0f }); XMStoreFloat4(&amp;vLightColors[0], { 0.75f, 0.75f, 0.75f, 1.0f });<br> XMStoreFloat4(&amp;vLightColors[1], { 1.0f, 0.75f, 0.25f, 1.0f });<br> <br> // Rotate the second light around the origin<br> XMMATRIX mRotate = XMMatrixRotationY(1 * t);<br> XMVECTOR vLightDir = XMLoadFloat4(&amp;vLightDirs[1]);<br> // rotates the second light<br> vLightDir = XMVector3Transform(vLightDir, mRotate);<br> XMStoreFloat4(&amp;vLightDirs[1], vLightDir);<br>}void renderGrid()<br>{<br> // set up default render state<br> // no blending<br> g_pImmediateContext-&gt;OMSetBlendState(nullptr, 0, 0xffffffff);<br> // solid, no wireframe<br> g_pImmediateContext-&gt;RSSetState(rasterStateDefault);<br> // write z<br> g_pImmediateContext-&gt;OMSetDepthStencilState(pDSState, 1); TransformsConstantBuffer cbDebug;<br> cbDebug.mWorld = XMMatrixIdentity();<br> cbDebug.mView = XMMatrixTranspose(g_View);<br> cbDebug.mProjection = XMMatrixTranspose(g_Projection);<br> g_pImmediateContext-&gt;UpdateSubresource(gridRenderable.constantBufferVS.Get(), 0, nullptr, &amp;cbDebug, 0, 0); gridRenderable.Bind(g_pImmediateContext);<br> gridRenderable.Draw(g_pImmediateContext);<br>}// Mesh render routine that supports toggling texturing<br>// and toggling overlay wireframe<br>void renderMesh(Renderable meshRenderable)<br>{<br> // copy transform to constant buffer<br> modelViewProjection.mWorld = XMMatrixTranspose(meshRenderable.world); // send the constant buffers to the GPU<br> g_pImmediateContext-&gt;UpdateSubresource(meshRenderable.constantBufferVS.Get(), 0, nullptr, &amp;modelViewProjection, 0, 0);<br> g_pImmediateContext-&gt;UpdateSubresource(meshRenderable.constantBufferPS.Get(), 0, nullptr, &amp;lightsAndColor, 0, 0); // set all of the render states<br> meshRenderable.Bind(g_pImmediateContext); // set the solid raster state<br> if (RASTER_FILL_CULL_NONE)<br> g_pImmediateContext-&gt;RSSetState(rasterStateFillNoCull);<br> else<br> g_pImmediateContext-&gt;RSSetState(rasterStateDefault); // if not textured, set the current texture to the generate white texture<br> if (!RENDER_STYLE_TEXTURED)<br> {<br> g_pImmediateContext-&gt;PSSetShaderResources(0, 1, texSRV.GetAddressOf());<br> }<br> if (RENDER_STYLE_TRANSPARENCY)<br> {<br> g_pImmediateContext-&gt;OMSetBlendState(transparencyState, 0, 0xffffffff);<br> }<br> else<br> {<br> g_pImmediateContext-&gt;OMSetBlendState(nullptr, 0, 0xffffffff);<br> } // Bind and Draw the vertices<br> meshRenderable.Draw(g_pImmediateContext); // redraw the whole mesh in wireframe mode<br> if (RENDER_STYLE_WIREFRAME)<br> {<br> g_pImmediateContext-&gt;OMSetBlendState(nullptr, 0, 0xffffffff); // Set the color of the wireframe<br> //cb1.vOutputColor = { 0.9f, 0.9f, 0.9f, 1.0f };<br> g_pImmediateContext-&gt;UpdateSubresource(meshRenderable.constantBufferVS.Get(), 0, nullptr, &amp;modelViewProjection, 0, 0); // set the solid pixel shader<br> g_pImmediateContext-&gt;PSSetShader(g_pPixelShaderSolid, nullptr, 0); // set the wireframe raster state<br> g_pImmediateContext-&gt;RSSetState(rasterStateWireframe); // Draw the mesh<br> meshRenderable.Draw(g_pImmediateContext);<br> }<br>}<br>//--------------------------------------------------------------------------------------<br>// Render a frame<br>//--------------------------------------------------------------------------------------<br>void Render()<br>{<br> //<br> // Clear the back buffer<br> //<br> g_pImmediateContext-&gt;ClearRenderTargetView(g_pRenderTargetView, Colors::MidnightBlue); //<br> // Clear the depth buffer to 1.0 (max depth)<br> //<br> g_pImmediateContext-&gt;ClearDepthStencilView(g_pDepthStencilView, D3D11_CLEAR_DEPTH, 1.0f, 0); //<br> // Render the grid<br> //<br> renderGrid(); //<br> // Update matrix variables and lighting variables<br> //<br> modelViewProjection.mView = XMMatrixTranspose(g_View);<br> modelViewProjection.mProjection = XMMatrixTranspose(g_Projection); lightsAndColor.vLightDir[0] = vLightDirs[0];<br> lightsAndColor.vLightDir[1] = vLightDirs[1];<br> lightsAndColor.vLightColor[0] = vLightColors[0];<br> lightsAndColor.vLightColor[1] = vLightColors[1];<br> lightsAndColor.vOutputColor = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f); //<br> // Render the renderables<br> //<br> if (DEPTH_WRITE_ENABLED)<br> g_pImmediateContext-&gt;OMSetDepthStencilState(pDSState, 1);<br> else<br> g_pImmediateContext-&gt;OMSetDepthStencilState(pDSStateNoWrite, 1); renderables[0].setRotation(g_World); // Render all of the renderables in the scene<br> for (auto r : renderables)<br> {<br> renderMesh(r);<br> } // TODO:RASTER STATE SOLID <br> g_pImmediateContext-&gt;RSSetState(rasterStateDefault);<br> g_pImmediateContext-&gt;OMSetDepthStencilState(pDSState, 1);<br> g_pImmediateContext-&gt;OMSetBlendState(nullptr, 0, 0xffffffff); // TODO:RASTER STATE SOLID <br> //g_pImmediateContext-&gt;RSSetState(rasterStateDefault); //<br> // Render each light<br> //<br> for (int m = 0; m &lt; 2; m++)<br> {<br> XMMATRIX mLight = XMMatrixTranslationFromVector(5.0f * XMLoadFloat4(&amp;vLightDirs[m]));<br> XMMATRIX mLightScale = XMMatrixScaling(0.2f, 0.2f, 0.2f);<br> mLight = mLightScale * mLight; // Update the world variable to reflect the current light<br> modelViewProjection.mWorld = XMMatrixTranspose(mLight);<br> lightsAndColor.vOutputColor = vLightColors[m];<br> g_pImmediateContext-&gt;RSSetState(rasterStateFillNoCull);<br> g_pImmediateContext-&gt;UpdateSubresource(renderables[0].constantBufferVS.Get(), 0, nullptr, &amp;modelViewProjection, 0, 0);<br> g_pImmediateContext-&gt;UpdateSubresource(renderables[0].constantBufferPS.Get(), 0, nullptr, &amp;lightsAndColor, 0, 0);<br> // inline override of the pixel shader<br> g_pImmediateContext-&gt;PSSetShader(g_pPixelShaderSolid, nullptr, 0);<br> renderables[0].Draw(g_pImmediateContext);<br> } /// Draw Skybox<br> if (SKYBOX_ENABLED)<br> {<br> TransformsConstantBuffer cbDebug;<br> cbDebug.mWorld = XMMatrixIdentity();<br> // zero out the camera postion so the skybox renders <br> // AT the camera postion<br> XMMATRIX tmpMat = g_View;<br> tmpMat.r[3] = { 0.0f, 0.0f, 0.0f, 1.0f };<br> cbDebug.mView = XMMatrixTranspose(tmpMat);<br> cbDebug.mProjection = XMMatrixTranspose(g_Projection); g_pImmediateContext-&gt;UpdateSubresource(skyboxRenderable.constantBufferVS.Get(), 0, nullptr, &amp;cbDebug, 0, 0);<br> g_pImmediateContext-&gt;OMSetDepthStencilState(pDSStateNoWrite, 1); skyboxRenderable.Bind(g_pImmediateContext);<br> skyboxRenderable.Draw(g_pImmediateContext);<br> //g_pImmediateContext-&gt;OMSetDepthStencilState(pDSState, 1);<br> } //<br> // Present our back buffer to our front buffer<br> //<br> g_pSwapChain-&gt;Present(0, 0);<br>}<br></p>
        </div>
      </nav>
    </div>
    <section id="Features" class="flex-container line curses w-container">
      <h2 class="heading-18"><strong>Programming Explanation</strong></h2>
    </section>
    <div class="container-7 w-container">
      <div class="rich-text-block-5 curses heading-curses ed w-richtext">
        <p><strong>DirecX FBX Scene</strong></p>
        <ul role="list">
          <li>The 3-D Content Creation course explores techniques used in the professional game industry to create and render content for real-time 3-D games. Topics covered include geometry, lighting, shading, texturing, the rendering pipeline, the content-creation pipeline, animation, and level editors. Student assignments include creating and animating content with 3-D modeling software and using a level editor to create environments for use in a commercial game engine.</li>
        </ul>
      </div><img src="../images/DiraectX_Leve1a.JPG" loading="lazy" sizes="(max-width: 479px) 96vw, (max-width: 767px) 97vw, (max-width: 991px) 728px, 940px" srcset="../images/DiraectX_Leve1a-p-500.jpeg 500w, ../images/DiraectX_Leve1a-p-800.jpeg 800w, ../images/DiraectX_Leve1a.JPG 1029w" alt="image">
      <div class="rich-text-block-5 curses heading-curses ed w-richtext">
        <p><strong>Controls</strong></p>
        <ul role="list">
          <li>WASD – move the camera</li>
          <li>Mouse to pick up and drag entities</li>
          <li>PGUP/PGDN – Change the Camera Mode</li>
          <li>Keys R will toggle viewing Level Render</li>
        </ul>
        <p>‍</p>
      </div>
      <div class="feature-image-mask"></div>
    </div>
  </div>
  <div class="section-2 footer background-black wf-section">
    <div class="container-4 w-container">
      <div class="footer-holder">
        <div class="social-wrapper">
          <a href="https://juan_diego_lugo.artstation.com" target="_blank" class="social-link w-inline-block"><img src="../images/Artstation.png" loading="lazy" alt="" class="image-13"></a>
          <a href="https://github.com/JDMAXilius" target="_blank" class="social-link w-inline-block"><img src="../images/github.png" loading="lazy" alt="image" class="image-13"></a>
          <a href="https://www.youtube.com/channel/UCRjr5hvDeIpc_SfgTO690RA/featured" target="_blank" class="social-link w-inline-block"><img src="../images/youtube.png" loading="lazy" alt="" class="image-13"></a>
          <a href="#" class="social-link w-inline-block"><img src="../images/pngfind.com-discord-icon-png-283551.png" loading="lazy" srcset="../images/pngfind.com-discord-icon-png-283551-p-500.png 500w, ../images/pngfind.com-discord-icon-png-283551-p-800.png 800w, ../images/pngfind.com-discord-icon-png-283551-p-1080.png 1080w, ../images/pngfind.com-discord-icon-png-283551.png 1468w" sizes="40px" alt="" class="image-13"></a>
          <a href="https://www.facebook.com/juandiego.lugo1" target="_blank" class="social-link w-inline-block"><img src="../images/fb.png" loading="lazy" alt="" class="image-13 f"></a>
          <a href="#" class="social-link w-inline-block"><img src="../images/Instagram.svg" loading="lazy" alt="Instagram logo" class="image-13"></a>
          <a href="https://www.linkedin.com/in/juan-diego-lugo-929a34205/" class="social-link w-inline-block"><img src="../images/LinkedIn.svg" loading="lazy" alt="LinkedIn logo" class="image-14"></a>
        </div><img src="https://uploads-ssl.webflow.com/602ca53e736379cc95d5f180/602ca53e58ea7fb6bb114f5c_Logo.svg" loading="lazy" width="187" alt="" class="image">
        <div class="text-block-3">@Juan Diego 2021<br>‍</div>
      </div>
    </div>
  </div>
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=602f42d4d0eb6ddf9136273c" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="../js/webflow.js" type="text/javascript"></script>
  <!-- [if lte IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/placeholders/3.0.2/placeholders.min.js"></script><![endif] -->
</body>
</html>